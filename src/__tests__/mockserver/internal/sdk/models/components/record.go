// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
	"mockserver/internal/sdk/optionalnullable"
	"mockserver/internal/sdk/utils"
)

// RecordType - Type of content:
// - FILE: Uploaded documents (PDF, DOCX, etc.)
// - WEBPAGE: Web pages crawled or bookmarked
// - COMMENT: Comments from collaboration tools
// - MESSAGE: Chat/messaging content (Slack, Teams)
// - EMAIL: Email messages (Gmail, Outlook)
// - TICKET: Support tickets (Jira, ServiceNow)
// - OTHERS: Miscellaneous content types
type RecordType string

const (
	RecordTypeFile    RecordType = "FILE"
	RecordTypeWebpage RecordType = "WEBPAGE"
	RecordTypeComment RecordType = "COMMENT"
	RecordTypeMessage RecordType = "MESSAGE"
	RecordTypeEmail   RecordType = "EMAIL"
	RecordTypeTicket  RecordType = "TICKET"
	RecordTypeOthers  RecordType = "OTHERS"
)

func (e RecordType) ToPointer() *RecordType {
	return &e
}
func (e *RecordType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "FILE":
		fallthrough
	case "WEBPAGE":
		fallthrough
	case "COMMENT":
		fallthrough
	case "MESSAGE":
		fallthrough
	case "EMAIL":
		fallthrough
	case "TICKET":
		fallthrough
	case "OTHERS":
		*e = RecordType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RecordType: %v", v)
	}
}

// Origin - Source of the record:
// - UPLOAD: Manually uploaded via API/UI
// - CONNECTOR: Synced from external connector
type Origin string

const (
	OriginUpload    Origin = "UPLOAD"
	OriginConnector Origin = "CONNECTOR"
)

func (e Origin) ToPointer() *Origin {
	return &e
}
func (e *Origin) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "UPLOAD":
		fallthrough
	case "CONNECTOR":
		*e = Origin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Origin: %v", v)
	}
}

// ConnectorName - Name of the source connector
type ConnectorName string

const (
	ConnectorNameKb               ConnectorName = "KB"
	ConnectorNameOnedrive         ConnectorName = "ONEDRIVE"
	ConnectorNameGoogleDrive      ConnectorName = "GOOGLE_DRIVE"
	ConnectorNameConfluence       ConnectorName = "CONFLUENCE"
	ConnectorNameJira             ConnectorName = "JIRA"
	ConnectorNameSlack            ConnectorName = "SLACK"
	ConnectorNameSharepointOnline ConnectorName = "SHAREPOINT_ONLINE"
	ConnectorNameGmail            ConnectorName = "GMAIL"
	ConnectorNameDropbox          ConnectorName = "DROPBOX"
	ConnectorNameOutlook          ConnectorName = "OUTLOOK"
	ConnectorNameServicenow       ConnectorName = "SERVICENOW"
	ConnectorNameBookstack        ConnectorName = "BOOKSTACK"
	ConnectorNameWeb              ConnectorName = "WEB"
)

func (e ConnectorName) ToPointer() *ConnectorName {
	return &e
}
func (e *ConnectorName) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "KB":
		fallthrough
	case "ONEDRIVE":
		fallthrough
	case "GOOGLE_DRIVE":
		fallthrough
	case "CONFLUENCE":
		fallthrough
	case "JIRA":
		fallthrough
	case "SLACK":
		fallthrough
	case "SHAREPOINT_ONLINE":
		fallthrough
	case "GMAIL":
		fallthrough
	case "DROPBOX":
		fallthrough
	case "OUTLOOK":
		fallthrough
	case "SERVICENOW":
		fallthrough
	case "BOOKSTACK":
		fallthrough
	case "WEB":
		*e = ConnectorName(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ConnectorName: %v", v)
	}
}

// IndexingStatus - Current indexing/processing status:
// - NOT_STARTED: Awaiting indexing
// - QUEUED: In indexing queue
// - IN_PROGRESS: Currently being indexed
// - COMPLETED: Successfully indexed and searchable
// - FAILED: Indexing failed (check error details)
// - PAUSED: Indexing paused by user
// - FILE_TYPE_NOT_SUPPORTED: Unsupported file format
// - AUTO_INDEX_OFF: Auto-indexing disabled for this record
// - EMPTY: File has no extractable content
// - ENABLE_MULTIMODAL_MODELS: Requires multimodal AI models
type IndexingStatus string

const (
	IndexingStatusNotStarted             IndexingStatus = "NOT_STARTED"
	IndexingStatusPaused                 IndexingStatus = "PAUSED"
	IndexingStatusInProgress             IndexingStatus = "IN_PROGRESS"
	IndexingStatusCompleted              IndexingStatus = "COMPLETED"
	IndexingStatusFailed                 IndexingStatus = "FAILED"
	IndexingStatusFileTypeNotSupported   IndexingStatus = "FILE_TYPE_NOT_SUPPORTED"
	IndexingStatusAutoIndexOff           IndexingStatus = "AUTO_INDEX_OFF"
	IndexingStatusEmpty                  IndexingStatus = "EMPTY"
	IndexingStatusEnableMultimodalModels IndexingStatus = "ENABLE_MULTIMODAL_MODELS"
	IndexingStatusQueued                 IndexingStatus = "QUEUED"
)

func (e IndexingStatus) ToPointer() *IndexingStatus {
	return &e
}
func (e *IndexingStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NOT_STARTED":
		fallthrough
	case "PAUSED":
		fallthrough
	case "IN_PROGRESS":
		fallthrough
	case "COMPLETED":
		fallthrough
	case "FAILED":
		fallthrough
	case "FILE_TYPE_NOT_SUPPORTED":
		fallthrough
	case "AUTO_INDEX_OFF":
		fallthrough
	case "EMPTY":
		fallthrough
	case "ENABLE_MULTIMODAL_MODELS":
		fallthrough
	case "QUEUED":
		*e = IndexingStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for IndexingStatus: %v", v)
	}
}

// FileRecord - File-specific metadata (present when recordType is FILE)
type FileRecord struct {
	ID          *string                                   `json:"id,omitempty"`
	Name        *string                                   `json:"name,omitempty"`
	Extension   *string                                   `json:"extension,omitempty"`
	MimeType    *string                                   `json:"mimeType,omitempty"`
	SizeInBytes *int64                                    `json:"sizeInBytes,omitempty"`
	WebURL      *string                                   `json:"webUrl,omitempty"`
	Path        optionalnullable.OptionalNullable[string] `json:"path,omitempty"`
	IsFile      *bool                                     `json:"isFile,omitempty"`
}

func (o *FileRecord) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *FileRecord) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *FileRecord) GetExtension() *string {
	if o == nil {
		return nil
	}
	return o.Extension
}

func (o *FileRecord) GetMimeType() *string {
	if o == nil {
		return nil
	}
	return o.MimeType
}

func (o *FileRecord) GetSizeInBytes() *int64 {
	if o == nil {
		return nil
	}
	return o.SizeInBytes
}

func (o *FileRecord) GetWebURL() *string {
	if o == nil {
		return nil
	}
	return o.WebURL
}

func (o *FileRecord) GetPath() optionalnullable.OptionalNullable[string] {
	if o == nil {
		return nil
	}
	return o.Path
}

func (o *FileRecord) GetIsFile() *bool {
	if o == nil {
		return nil
	}
	return o.IsFile
}

// MailRecord - Email-specific metadata (present when recordType is EMAIL)
type MailRecord struct {
}

// TicketRecord - Ticket-specific metadata (present when recordType is TICKET)
type TicketRecord struct {
}

// Record - A record represents a single document, file, or content item within a knowledge base.
// Records can originate from file uploads or external connectors (Google Drive, OneDrive, etc.).
type Record struct {
	// Unique record identifier (UUID format)
	ID *string `json:"id,omitempty"`
	// Display name of the record
	RecordName string `json:"recordName"`
	// Display name (alias for recordName)
	Name *string `json:"name,omitempty"`
	// External storage document ID (links to Storage module)
	ExternalRecordID *string `json:"externalRecordId,omitempty"`
	// Type of content:
	// - FILE: Uploaded documents (PDF, DOCX, etc.)
	// - WEBPAGE: Web pages crawled or bookmarked
	// - COMMENT: Comments from collaboration tools
	// - MESSAGE: Chat/messaging content (Slack, Teams)
	// - EMAIL: Email messages (Gmail, Outlook)
	// - TICKET: Support tickets (Jira, ServiceNow)
	// - OTHERS: Miscellaneous content types
	//
	RecordType RecordType `json:"recordType"`
	// Source of the record:
	// - UPLOAD: Manually uploaded via API/UI
	// - CONNECTOR: Synced from external connector
	//
	Origin Origin `json:"origin"`
	// ID of the connector that synced this record (null for uploads)
	ConnectorID *string `json:"connectorId,omitempty"`
	// Name of the source connector
	ConnectorName *ConnectorName `json:"connectorName,omitempty"`
	// Organization ID that owns this record
	OrgID string `json:"orgId"`
	// Knowledge base ID containing this record
	KbID *string `json:"kbId,omitempty"`
	// Parent folder ID (null if at KB root)
	FolderID optionalnullable.OptionalNullable[string] `json:"folderId,omitempty"`
	// Current version number (increments on updates)
	Version *int64 `default:"0" json:"version"`
	// Whether this is the latest version
	IsLatestVersion *bool `json:"isLatestVersion,omitempty"`
	// Creation timestamp in milliseconds
	CreatedAtTimestamp *int64 `json:"createdAtTimestamp,omitempty"`
	// Last update timestamp in milliseconds
	UpdatedAtTimestamp *int64 `json:"updatedAtTimestamp,omitempty"`
	// Source creation timestamp (from connector)
	SourceCreatedAtTimestamp *int64 `json:"sourceCreatedAtTimestamp,omitempty"`
	// Source last modified timestamp (from connector)
	SourceLastModifiedTimestamp *int64 `json:"sourceLastModifiedTimestamp,omitempty"`
	// Current indexing/processing status:
	// - NOT_STARTED: Awaiting indexing
	// - QUEUED: In indexing queue
	// - IN_PROGRESS: Currently being indexed
	// - COMPLETED: Successfully indexed and searchable
	// - FAILED: Indexing failed (check error details)
	// - PAUSED: Indexing paused by user
	// - FILE_TYPE_NOT_SUPPORTED: Unsupported file format
	// - AUTO_INDEX_OFF: Auto-indexing disabled for this record
	// - EMPTY: File has no extractable content
	// - ENABLE_MULTIMODAL_MODELS: Requires multimodal AI models
	//
	IndexingStatus *IndexingStatus `json:"indexingStatus,omitempty"`
	// Soft delete flag
	IsDeleted *bool `default:"false" json:"isDeleted"`
	// Archive flag for inactive records
	IsArchived *bool `default:"false" json:"isArchived"`
	// Direct URL to access the original content
	WebURL *string `json:"webUrl,omitempty"`
	// MIME type of the file content
	MimeType *string `json:"mimeType,omitempty"`
	// File size in bytes
	SizeInBytes *int64 `json:"sizeInBytes,omitempty"`
	// File extension (without dot)
	Extension *string `json:"extension,omitempty"`
	// SHA-256 hash for content deduplication
	Sha256Hash *string `json:"sha256Hash,omitempty"`
	// Node type identifier
	Type *string `json:"type,omitempty"`
	// File-specific metadata (present when recordType is FILE)
	FileRecord optionalnullable.OptionalNullable[FileRecord] `json:"fileRecord,omitempty"`
	// Email-specific metadata (present when recordType is EMAIL)
	MailRecord optionalnullable.OptionalNullable[MailRecord] `json:"mailRecord,omitempty"`
	// Ticket-specific metadata (present when recordType is TICKET)
	TicketRecord optionalnullable.OptionalNullable[TicketRecord] `json:"ticketRecord,omitempty"`
}

func (r Record) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *Record) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, []string{"recordName", "recordType", "origin", "orgId"}); err != nil {
		return err
	}
	return nil
}

func (o *Record) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Record) GetRecordName() string {
	if o == nil {
		return ""
	}
	return o.RecordName
}

func (o *Record) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Record) GetExternalRecordID() *string {
	if o == nil {
		return nil
	}
	return o.ExternalRecordID
}

func (o *Record) GetRecordType() RecordType {
	if o == nil {
		return RecordType("")
	}
	return o.RecordType
}

func (o *Record) GetOrigin() Origin {
	if o == nil {
		return Origin("")
	}
	return o.Origin
}

func (o *Record) GetConnectorID() *string {
	if o == nil {
		return nil
	}
	return o.ConnectorID
}

func (o *Record) GetConnectorName() *ConnectorName {
	if o == nil {
		return nil
	}
	return o.ConnectorName
}

func (o *Record) GetOrgID() string {
	if o == nil {
		return ""
	}
	return o.OrgID
}

func (o *Record) GetKbID() *string {
	if o == nil {
		return nil
	}
	return o.KbID
}

func (o *Record) GetFolderID() optionalnullable.OptionalNullable[string] {
	if o == nil {
		return nil
	}
	return o.FolderID
}

func (o *Record) GetVersion() *int64 {
	if o == nil {
		return nil
	}
	return o.Version
}

func (o *Record) GetIsLatestVersion() *bool {
	if o == nil {
		return nil
	}
	return o.IsLatestVersion
}

func (o *Record) GetCreatedAtTimestamp() *int64 {
	if o == nil {
		return nil
	}
	return o.CreatedAtTimestamp
}

func (o *Record) GetUpdatedAtTimestamp() *int64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAtTimestamp
}

func (o *Record) GetSourceCreatedAtTimestamp() *int64 {
	if o == nil {
		return nil
	}
	return o.SourceCreatedAtTimestamp
}

func (o *Record) GetSourceLastModifiedTimestamp() *int64 {
	if o == nil {
		return nil
	}
	return o.SourceLastModifiedTimestamp
}

func (o *Record) GetIndexingStatus() *IndexingStatus {
	if o == nil {
		return nil
	}
	return o.IndexingStatus
}

func (o *Record) GetIsDeleted() *bool {
	if o == nil {
		return nil
	}
	return o.IsDeleted
}

func (o *Record) GetIsArchived() *bool {
	if o == nil {
		return nil
	}
	return o.IsArchived
}

func (o *Record) GetWebURL() *string {
	if o == nil {
		return nil
	}
	return o.WebURL
}

func (o *Record) GetMimeType() *string {
	if o == nil {
		return nil
	}
	return o.MimeType
}

func (o *Record) GetSizeInBytes() *int64 {
	if o == nil {
		return nil
	}
	return o.SizeInBytes
}

func (o *Record) GetExtension() *string {
	if o == nil {
		return nil
	}
	return o.Extension
}

func (o *Record) GetSha256Hash() *string {
	if o == nil {
		return nil
	}
	return o.Sha256Hash
}

func (o *Record) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *Record) GetFileRecord() optionalnullable.OptionalNullable[FileRecord] {
	if o == nil {
		return nil
	}
	return o.FileRecord
}

func (o *Record) GetMailRecord() optionalnullable.OptionalNullable[MailRecord] {
	if o == nil {
		return nil
	}
	return o.MailRecord
}

func (o *Record) GetTicketRecord() optionalnullable.OptionalNullable[TicketRecord] {
	if o == nil {
		return nil
	}
	return o.TicketRecord
}
