// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
	"mockserver/internal/sdk/utils"
	"time"
)

type SearchResultAccessLevel string

const (
	SearchResultAccessLevelRead  SearchResultAccessLevel = "read"
	SearchResultAccessLevelWrite SearchResultAccessLevel = "write"
)

func (e SearchResultAccessLevel) ToPointer() *SearchResultAccessLevel {
	return &e
}
func (e *SearchResultAccessLevel) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "read":
		fallthrough
	case "write":
		*e = SearchResultAccessLevel(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SearchResultAccessLevel: %v", v)
	}
}

type SearchResultSharedWith struct {
	UserID      *string                  `json:"userId,omitempty"`
	AccessLevel *SearchResultAccessLevel `json:"accessLevel,omitempty"`
}

func (o *SearchResultSharedWith) GetUserID() *string {
	if o == nil {
		return nil
	}
	return o.UserID
}

func (o *SearchResultSharedWith) GetAccessLevel() *SearchResultAccessLevel {
	if o == nil {
		return nil
	}
	return o.AccessLevel
}

// SearchResult - Result of a semantic search operation, containing matching
// document chunks with relevance scores.
type SearchResult struct {
	// Unique search record identifier
	ID *string `json:"_id,omitempty"`
	// Alias for _id
	SearchID *string `json:"searchId,omitempty"`
	// The original search query
	Query *string `json:"query,omitempty"`
	// Matching content chunks
	Results []SearchResultItem `json:"results,omitempty"`
	// Map of record IDs to record names
	Records    map[string]string        `json:"records,omitempty"`
	UserID     *string                  `json:"userId,omitempty"`
	OrgID      *string                  `json:"orgId,omitempty"`
	IsShared   *bool                    `default:"false" json:"isShared"`
	SharedWith []SearchResultSharedWith `json:"sharedWith,omitempty"`
	IsArchived *bool                    `default:"false" json:"isArchived"`
	CreatedAt  *time.Time               `json:"createdAt,omitempty"`
}

func (s SearchResult) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SearchResult) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *SearchResult) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *SearchResult) GetSearchID() *string {
	if o == nil {
		return nil
	}
	return o.SearchID
}

func (o *SearchResult) GetQuery() *string {
	if o == nil {
		return nil
	}
	return o.Query
}

func (o *SearchResult) GetResults() []SearchResultItem {
	if o == nil {
		return nil
	}
	return o.Results
}

func (o *SearchResult) GetRecords() map[string]string {
	if o == nil {
		return nil
	}
	return o.Records
}

func (o *SearchResult) GetUserID() *string {
	if o == nil {
		return nil
	}
	return o.UserID
}

func (o *SearchResult) GetOrgID() *string {
	if o == nil {
		return nil
	}
	return o.OrgID
}

func (o *SearchResult) GetIsShared() *bool {
	if o == nil {
		return nil
	}
	return o.IsShared
}

func (o *SearchResult) GetSharedWith() []SearchResultSharedWith {
	if o == nil {
		return nil
	}
	return o.SharedWith
}

func (o *SearchResult) GetIsArchived() *bool {
	if o == nil {
		return nil
	}
	return o.IsArchived
}

func (o *SearchResult) GetCreatedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}
