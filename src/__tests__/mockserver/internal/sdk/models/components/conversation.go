// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
	"mockserver/internal/sdk/utils"
	"time"
)

// ConversationStatus - Current status of the conversation:
// <ul>
// <li><code>INPROGRESS</code> - AI is processing</li>
// <li><code>COMPLETED</code> - Response ready</li>
// <li><code>FAILED</code> - Error occurred</li>
// </ul>
type ConversationStatus string

const (
	ConversationStatusInprogress ConversationStatus = "INPROGRESS"
	ConversationStatusCompleted  ConversationStatus = "COMPLETED"
	ConversationStatusFailed     ConversationStatus = "FAILED"
)

func (e ConversationStatus) ToPointer() *ConversationStatus {
	return &e
}
func (e *ConversationStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "INPROGRESS":
		fallthrough
	case "COMPLETED":
		fallthrough
	case "FAILED":
		*e = ConversationStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ConversationStatus: %v", v)
	}
}

// ModelInfo - AI model configuration used
type ModelInfo struct {
	ModelKey      *string `json:"modelKey,omitempty"`
	ModelName     *string `json:"modelName,omitempty"`
	ModelProvider *string `json:"modelProvider,omitempty"`
	ChatMode      *string `json:"chatMode,omitempty"`
}

func (o *ModelInfo) GetModelKey() *string {
	if o == nil {
		return nil
	}
	return o.ModelKey
}

func (o *ModelInfo) GetModelName() *string {
	if o == nil {
		return nil
	}
	return o.ModelName
}

func (o *ModelInfo) GetModelProvider() *string {
	if o == nil {
		return nil
	}
	return o.ModelProvider
}

func (o *ModelInfo) GetChatMode() *string {
	if o == nil {
		return nil
	}
	return o.ChatMode
}

type ConversationAccessLevel string

const (
	ConversationAccessLevelRead  ConversationAccessLevel = "read"
	ConversationAccessLevelWrite ConversationAccessLevel = "write"
)

func (e ConversationAccessLevel) ToPointer() *ConversationAccessLevel {
	return &e
}
func (e *ConversationAccessLevel) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "read":
		fallthrough
	case "write":
		*e = ConversationAccessLevel(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ConversationAccessLevel: %v", v)
	}
}

type ConversationSharedWith struct {
	UserID      *string                  `json:"userId,omitempty"`
	AccessLevel *ConversationAccessLevel `json:"accessLevel,omitempty"`
}

func (o *ConversationSharedWith) GetUserID() *string {
	if o == nil {
		return nil
	}
	return o.UserID
}

func (o *ConversationSharedWith) GetAccessLevel() *ConversationAccessLevel {
	if o == nil {
		return nil
	}
	return o.AccessLevel
}

// Conversation - A conversation represents a chat session between a user and the AI.
// Conversations maintain context across multiple messages and can be
// shared, archived, and organized.
type Conversation struct {
	// Unique conversation identifier
	ID *string `json:"_id,omitempty"`
	// ID of the user who owns this conversation
	UserID *string `json:"userId,omitempty"`
	// Organization this conversation belongs to
	OrgID *string `json:"orgId,omitempty"`
	// Conversation title, auto-generated from first query
	// or manually updated
	//
	Title *string `json:"title,omitempty"`
	// User who started the conversation
	Initiator *string `json:"initiator,omitempty"`
	// All messages in this conversation
	Messages []Message `json:"messages,omitempty"`
	// Current status of the conversation:
	// <ul>
	// <li><code>INPROGRESS</code> - AI is processing</li>
	// <li><code>COMPLETED</code> - Response ready</li>
	// <li><code>FAILED</code> - Error occurred</li>
	// </ul>
	//
	Status *ConversationStatus `json:"status,omitempty"`
	// Error description if status is FAILED
	FailReason *string `json:"failReason,omitempty"`
	// AI model configuration used
	ModelInfo *ModelInfo `json:"modelInfo,omitempty"`
	// Whether this conversation is shared with others
	IsShared *bool `default:"false" json:"isShared"`
	// Shareable link if conversation is shared
	ShareLink *string `json:"shareLink,omitempty"`
	// Users this conversation is shared with
	SharedWith []ConversationSharedWith `json:"sharedWith,omitempty"`
	// Whether this conversation is archived
	IsArchived *bool `default:"false" json:"isArchived"`
	// User who archived this conversation
	ArchivedBy *string `json:"archivedBy,omitempty"`
	// Unix timestamp of last activity
	LastActivityAt *int64     `json:"lastActivityAt,omitempty"`
	CreatedAt      *time.Time `json:"createdAt,omitempty"`
	UpdatedAt      *time.Time `json:"updatedAt,omitempty"`
}

func (c Conversation) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *Conversation) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *Conversation) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Conversation) GetUserID() *string {
	if o == nil {
		return nil
	}
	return o.UserID
}

func (o *Conversation) GetOrgID() *string {
	if o == nil {
		return nil
	}
	return o.OrgID
}

func (o *Conversation) GetTitle() *string {
	if o == nil {
		return nil
	}
	return o.Title
}

func (o *Conversation) GetInitiator() *string {
	if o == nil {
		return nil
	}
	return o.Initiator
}

func (o *Conversation) GetMessages() []Message {
	if o == nil {
		return nil
	}
	return o.Messages
}

func (o *Conversation) GetStatus() *ConversationStatus {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *Conversation) GetFailReason() *string {
	if o == nil {
		return nil
	}
	return o.FailReason
}

func (o *Conversation) GetModelInfo() *ModelInfo {
	if o == nil {
		return nil
	}
	return o.ModelInfo
}

func (o *Conversation) GetIsShared() *bool {
	if o == nil {
		return nil
	}
	return o.IsShared
}

func (o *Conversation) GetShareLink() *string {
	if o == nil {
		return nil
	}
	return o.ShareLink
}

func (o *Conversation) GetSharedWith() []ConversationSharedWith {
	if o == nil {
		return nil
	}
	return o.SharedWith
}

func (o *Conversation) GetIsArchived() *bool {
	if o == nil {
		return nil
	}
	return o.IsArchived
}

func (o *Conversation) GetArchivedBy() *string {
	if o == nil {
		return nil
	}
	return o.ArchivedBy
}

func (o *Conversation) GetLastActivityAt() *int64 {
	if o == nil {
		return nil
	}
	return o.LastActivityAt
}

func (o *Conversation) GetCreatedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *Conversation) GetUpdatedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}
