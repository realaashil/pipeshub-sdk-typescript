// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
	"mockserver/internal/sdk/utils"
	"time"
)

// MessageType - Type of message:
// <ul>
// <li><code>user_query</code> - User's question or input</li>
// <li><code>bot_response</code> - AI-generated response</li>
// <li><code>error</code> - Error message from the system</li>
// <li><code>feedback</code> - User feedback on a response</li>
// <li><code>system</code> - System notification or status</li>
// </ul>
type MessageType string

const (
	MessageTypeUserQuery   MessageType = "user_query"
	MessageTypeBotResponse MessageType = "bot_response"
	MessageTypeError       MessageType = "error"
	MessageTypeFeedback    MessageType = "feedback"
	MessageTypeSystem      MessageType = "system"
)

func (e MessageType) ToPointer() *MessageType {
	return &e
}
func (e *MessageType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user_query":
		fallthrough
	case "bot_response":
		fallthrough
	case "error":
		fallthrough
	case "feedback":
		fallthrough
	case "system":
		*e = MessageType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MessageType: %v", v)
	}
}

// ContentFormat - Format of the content for rendering
type ContentFormat string

const (
	ContentFormatMarkdown ContentFormat = "MARKDOWN"
	ContentFormatJSON     ContentFormat = "JSON"
	ContentFormatHTML     ContentFormat = "HTML"
)

func (e ContentFormat) ToPointer() *ContentFormat {
	return &e
}
func (e *ContentFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MARKDOWN":
		fallthrough
	case "JSON":
		fallthrough
	case "HTML":
		*e = ContentFormat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ContentFormat: %v", v)
	}
}

type MessageMetadata struct {
	// Time taken to generate response in milliseconds
	ProcessingTimeMs *float64 `json:"processingTimeMs,omitempty"`
	// Version of the AI model used
	ModelVersion *string `json:"modelVersion,omitempty"`
	// Transaction ID for tracking in AI backend
	AiTransactionID *string `json:"aiTransactionId,omitempty"`
	// Additional context or reasoning
	Reason *string `json:"reason,omitempty"`
}

func (o *MessageMetadata) GetProcessingTimeMs() *float64 {
	if o == nil {
		return nil
	}
	return o.ProcessingTimeMs
}

func (o *MessageMetadata) GetModelVersion() *string {
	if o == nil {
		return nil
	}
	return o.ModelVersion
}

func (o *MessageMetadata) GetAiTransactionID() *string {
	if o == nil {
		return nil
	}
	return o.AiTransactionID
}

func (o *MessageMetadata) GetReason() *string {
	if o == nil {
		return nil
	}
	return o.Reason
}

// Message - A single message within a conversation. Messages can be user queries,
// AI responses, system messages, or error notifications.
type Message struct {
	// Unique message identifier
	ID *string `json:"_id,omitempty"`
	// Type of message:
	// <ul>
	// <li><code>user_query</code> - User's question or input</li>
	// <li><code>bot_response</code> - AI-generated response</li>
	// <li><code>error</code> - Error message from the system</li>
	// <li><code>feedback</code> - User feedback on a response</li>
	// <li><code>system</code> - System notification or status</li>
	// </ul>
	//
	MessageType *MessageType `json:"messageType,omitempty"`
	// The message text content
	Content *string `json:"content,omitempty"`
	// Format of the content for rendering
	ContentFormat *ContentFormat `default:"MARKDOWN" json:"contentFormat"`
	// References to source documents used in the response
	Citations []CitationReference `json:"citations,omitempty"`
	// AI's confidence level in the response
	Confidence *string `json:"confidence,omitempty"`
	// Suggested follow-up questions
	FollowUpQuestions []FollowUpQuestion `json:"followUpQuestions,omitempty"`
	// User feedback on this message
	Feedback  []MessageFeedback `json:"feedback,omitempty"`
	Metadata  *MessageMetadata  `json:"metadata,omitempty"`
	CreatedAt *time.Time        `json:"createdAt,omitempty"`
	UpdatedAt *time.Time        `json:"updatedAt,omitempty"`
}

func (m Message) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *Message) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *Message) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Message) GetMessageType() *MessageType {
	if o == nil {
		return nil
	}
	return o.MessageType
}

func (o *Message) GetContent() *string {
	if o == nil {
		return nil
	}
	return o.Content
}

func (o *Message) GetContentFormat() *ContentFormat {
	if o == nil {
		return nil
	}
	return o.ContentFormat
}

func (o *Message) GetCitations() []CitationReference {
	if o == nil {
		return nil
	}
	return o.Citations
}

func (o *Message) GetConfidence() *string {
	if o == nil {
		return nil
	}
	return o.Confidence
}

func (o *Message) GetFollowUpQuestions() []FollowUpQuestion {
	if o == nil {
		return nil
	}
	return o.FollowUpQuestions
}

func (o *Message) GetFeedback() []MessageFeedback {
	if o == nil {
		return nil
	}
	return o.Feedback
}

func (o *Message) GetMetadata() *MessageMetadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *Message) GetCreatedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *Message) GetUpdatedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}
