// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
	"time"
)

// GetConversationByIDSortOrder - Sort direction
type GetConversationByIDSortOrder string

const (
	GetConversationByIDSortOrderAsc  GetConversationByIDSortOrder = "asc"
	GetConversationByIDSortOrderDesc GetConversationByIDSortOrder = "desc"
)

func (e GetConversationByIDSortOrder) ToPointer() *GetConversationByIDSortOrder {
	return &e
}
func (e *GetConversationByIDSortOrder) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "asc":
		fallthrough
	case "desc":
		*e = GetConversationByIDSortOrder(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetConversationByIDSortOrder: %v", v)
	}
}

type GetConversationByIDRequest struct {
	// Unique conversation identifier
	ConversationID string `pathParam:"style=simple,explode=false,name=conversationId"`
	// Page number for message pagination
	Page *int64 `default:"1" queryParam:"style=form,explode=true,name=page"`
	// Number of messages per page
	Limit *int64 `default:"10" queryParam:"style=form,explode=true,name=limit"`
	// Field to sort messages by
	SortBy *string `default:"createdAt" queryParam:"style=form,explode=true,name=sortBy"`
	// Sort direction
	SortOrder *GetConversationByIDSortOrder `default:"desc" queryParam:"style=form,explode=true,name=sortOrder"`
}

func (g GetConversationByIDRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetConversationByIDRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"conversationId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetConversationByIDRequest) GetConversationID() string {
	if o == nil {
		return ""
	}
	return o.ConversationID
}

func (o *GetConversationByIDRequest) GetPage() *int64 {
	if o == nil {
		return nil
	}
	return o.Page
}

func (o *GetConversationByIDRequest) GetLimit() *int64 {
	if o == nil {
		return nil
	}
	return o.Limit
}

func (o *GetConversationByIDRequest) GetSortBy() *string {
	if o == nil {
		return nil
	}
	return o.SortBy
}

func (o *GetConversationByIDRequest) GetSortOrder() *GetConversationByIDSortOrder {
	if o == nil {
		return nil
	}
	return o.SortOrder
}

// GetConversationByIDStatus - Current status of the conversation:
// <ul>
// <li><code>INPROGRESS</code> - AI is processing</li>
// <li><code>COMPLETED</code> - Response ready</li>
// <li><code>FAILED</code> - Error occurred</li>
// </ul>
type GetConversationByIDStatus string

const (
	GetConversationByIDStatusInprogress GetConversationByIDStatus = "INPROGRESS"
	GetConversationByIDStatusCompleted  GetConversationByIDStatus = "COMPLETED"
	GetConversationByIDStatusFailed     GetConversationByIDStatus = "FAILED"
)

func (e GetConversationByIDStatus) ToPointer() *GetConversationByIDStatus {
	return &e
}
func (e *GetConversationByIDStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "INPROGRESS":
		fallthrough
	case "COMPLETED":
		fallthrough
	case "FAILED":
		*e = GetConversationByIDStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetConversationByIDStatus: %v", v)
	}
}

// ModelInfo - AI model configuration used
type ModelInfo struct {
	ModelKey      *string `json:"modelKey,omitempty"`
	ModelName     *string `json:"modelName,omitempty"`
	ModelProvider *string `json:"modelProvider,omitempty"`
	ChatMode      *string `json:"chatMode,omitempty"`
}

func (o *ModelInfo) GetModelKey() *string {
	if o == nil {
		return nil
	}
	return o.ModelKey
}

func (o *ModelInfo) GetModelName() *string {
	if o == nil {
		return nil
	}
	return o.ModelName
}

func (o *ModelInfo) GetModelProvider() *string {
	if o == nil {
		return nil
	}
	return o.ModelProvider
}

func (o *ModelInfo) GetChatMode() *string {
	if o == nil {
		return nil
	}
	return o.ChatMode
}

type GetConversationByIDAccessLevel string

const (
	GetConversationByIDAccessLevelRead  GetConversationByIDAccessLevel = "read"
	GetConversationByIDAccessLevelWrite GetConversationByIDAccessLevel = "write"
)

func (e GetConversationByIDAccessLevel) ToPointer() *GetConversationByIDAccessLevel {
	return &e
}
func (e *GetConversationByIDAccessLevel) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "read":
		fallthrough
	case "write":
		*e = GetConversationByIDAccessLevel(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetConversationByIDAccessLevel: %v", v)
	}
}

type GetConversationByIDSharedWith struct {
	UserID      *string                         `json:"userId,omitempty"`
	AccessLevel *GetConversationByIDAccessLevel `json:"accessLevel,omitempty"`
}

func (o *GetConversationByIDSharedWith) GetUserID() *string {
	if o == nil {
		return nil
	}
	return o.UserID
}

func (o *GetConversationByIDSharedWith) GetAccessLevel() *GetConversationByIDAccessLevel {
	if o == nil {
		return nil
	}
	return o.AccessLevel
}

type GetConversationByIDPagination struct {
	Page          *int64 `json:"page,omitempty"`
	Limit         *int64 `json:"limit,omitempty"`
	TotalMessages *int64 `json:"totalMessages,omitempty"`
	TotalPages    *int64 `json:"totalPages,omitempty"`
}

func (o *GetConversationByIDPagination) GetPage() *int64 {
	if o == nil {
		return nil
	}
	return o.Page
}

func (o *GetConversationByIDPagination) GetLimit() *int64 {
	if o == nil {
		return nil
	}
	return o.Limit
}

func (o *GetConversationByIDPagination) GetTotalMessages() *int64 {
	if o == nil {
		return nil
	}
	return o.TotalMessages
}

func (o *GetConversationByIDPagination) GetTotalPages() *int64 {
	if o == nil {
		return nil
	}
	return o.TotalPages
}

// GetConversationByIDResponseBody - A conversation represents a chat session between a user and the AI.
// Conversations maintain context across multiple messages and can be
// shared, archived, and organized.
type GetConversationByIDResponseBody struct {
	// Unique conversation identifier
	ID *string `json:"_id,omitempty"`
	// ID of the user who owns this conversation
	UserID *string `json:"userId,omitempty"`
	// Organization this conversation belongs to
	OrgID *string `json:"orgId,omitempty"`
	// Conversation title, auto-generated from first query
	// or manually updated
	//
	Title *string `json:"title,omitempty"`
	// User who started the conversation
	Initiator *string `json:"initiator,omitempty"`
	// All messages in this conversation
	Messages []components.Message `json:"messages,omitempty"`
	// Current status of the conversation:
	// <ul>
	// <li><code>INPROGRESS</code> - AI is processing</li>
	// <li><code>COMPLETED</code> - Response ready</li>
	// <li><code>FAILED</code> - Error occurred</li>
	// </ul>
	//
	Status *GetConversationByIDStatus `json:"status,omitempty"`
	// Error description if status is FAILED
	FailReason *string `json:"failReason,omitempty"`
	// AI model configuration used
	ModelInfo *ModelInfo `json:"modelInfo,omitempty"`
	// Whether this conversation is shared with others
	IsShared *bool `default:"false" json:"isShared"`
	// Shareable link if conversation is shared
	ShareLink *string `json:"shareLink,omitempty"`
	// Users this conversation is shared with
	SharedWith []GetConversationByIDSharedWith `json:"sharedWith,omitempty"`
	// Whether this conversation is archived
	IsArchived *bool `default:"false" json:"isArchived"`
	// User who archived this conversation
	ArchivedBy *string `json:"archivedBy,omitempty"`
	// Unix timestamp of last activity
	LastActivityAt *int64                         `json:"lastActivityAt,omitempty"`
	CreatedAt      *time.Time                     `json:"createdAt,omitempty"`
	UpdatedAt      *time.Time                     `json:"updatedAt,omitempty"`
	Pagination     *GetConversationByIDPagination `json:"pagination,omitempty"`
}

func (g GetConversationByIDResponseBody) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetConversationByIDResponseBody) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetConversationByIDResponseBody) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *GetConversationByIDResponseBody) GetUserID() *string {
	if o == nil {
		return nil
	}
	return o.UserID
}

func (o *GetConversationByIDResponseBody) GetOrgID() *string {
	if o == nil {
		return nil
	}
	return o.OrgID
}

func (o *GetConversationByIDResponseBody) GetTitle() *string {
	if o == nil {
		return nil
	}
	return o.Title
}

func (o *GetConversationByIDResponseBody) GetInitiator() *string {
	if o == nil {
		return nil
	}
	return o.Initiator
}

func (o *GetConversationByIDResponseBody) GetMessages() []components.Message {
	if o == nil {
		return nil
	}
	return o.Messages
}

func (o *GetConversationByIDResponseBody) GetStatus() *GetConversationByIDStatus {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *GetConversationByIDResponseBody) GetFailReason() *string {
	if o == nil {
		return nil
	}
	return o.FailReason
}

func (o *GetConversationByIDResponseBody) GetModelInfo() *ModelInfo {
	if o == nil {
		return nil
	}
	return o.ModelInfo
}

func (o *GetConversationByIDResponseBody) GetIsShared() *bool {
	if o == nil {
		return nil
	}
	return o.IsShared
}

func (o *GetConversationByIDResponseBody) GetShareLink() *string {
	if o == nil {
		return nil
	}
	return o.ShareLink
}

func (o *GetConversationByIDResponseBody) GetSharedWith() []GetConversationByIDSharedWith {
	if o == nil {
		return nil
	}
	return o.SharedWith
}

func (o *GetConversationByIDResponseBody) GetIsArchived() *bool {
	if o == nil {
		return nil
	}
	return o.IsArchived
}

func (o *GetConversationByIDResponseBody) GetArchivedBy() *string {
	if o == nil {
		return nil
	}
	return o.ArchivedBy
}

func (o *GetConversationByIDResponseBody) GetLastActivityAt() *int64 {
	if o == nil {
		return nil
	}
	return o.LastActivityAt
}

func (o *GetConversationByIDResponseBody) GetCreatedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *GetConversationByIDResponseBody) GetUpdatedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *GetConversationByIDResponseBody) GetPagination() *GetConversationByIDPagination {
	if o == nil {
		return nil
	}
	return o.Pagination
}

type GetConversationByIDResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// Conversation with paginated messages
	Object *GetConversationByIDResponseBody
}

func (o *GetConversationByIDResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *GetConversationByIDResponse) GetObject() *GetConversationByIDResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
