/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

/**
 * Type of content:
 *
 * @remarks
 * - FILE: Uploaded documents (PDF, DOCX, etc.)
 * - WEBPAGE: Web pages crawled or bookmarked
 * - COMMENT: Comments from collaboration tools
 * - MESSAGE: Chat/messaging content (Slack, Teams)
 * - EMAIL: Email messages (Gmail, Outlook)
 * - TICKET: Support tickets (Jira, ServiceNow)
 * - OTHERS: Miscellaneous content types
 */
export const RecordType = {
  File: "FILE",
  Webpage: "WEBPAGE",
  Comment: "COMMENT",
  Message: "MESSAGE",
  Email: "EMAIL",
  Ticket: "TICKET",
  Others: "OTHERS",
} as const;
/**
 * Type of content:
 *
 * @remarks
 * - FILE: Uploaded documents (PDF, DOCX, etc.)
 * - WEBPAGE: Web pages crawled or bookmarked
 * - COMMENT: Comments from collaboration tools
 * - MESSAGE: Chat/messaging content (Slack, Teams)
 * - EMAIL: Email messages (Gmail, Outlook)
 * - TICKET: Support tickets (Jira, ServiceNow)
 * - OTHERS: Miscellaneous content types
 */
export type RecordType = OpenEnum<typeof RecordType>;

/**
 * Source of the record:
 *
 * @remarks
 * - UPLOAD: Manually uploaded via API/UI
 * - CONNECTOR: Synced from external connector
 */
export const Origin = {
  Upload: "UPLOAD",
  Connector: "CONNECTOR",
} as const;
/**
 * Source of the record:
 *
 * @remarks
 * - UPLOAD: Manually uploaded via API/UI
 * - CONNECTOR: Synced from external connector
 */
export type Origin = OpenEnum<typeof Origin>;

/**
 * Name of the source connector
 */
export const ConnectorName = {
  Kb: "KB",
  Onedrive: "ONEDRIVE",
  GoogleDrive: "GOOGLE_DRIVE",
  Confluence: "CONFLUENCE",
  Jira: "JIRA",
  Slack: "SLACK",
  SharepointOnline: "SHAREPOINT_ONLINE",
  Gmail: "GMAIL",
  Dropbox: "DROPBOX",
  Outlook: "OUTLOOK",
  Servicenow: "SERVICENOW",
  Bookstack: "BOOKSTACK",
  Web: "WEB",
} as const;
/**
 * Name of the source connector
 */
export type ConnectorName = OpenEnum<typeof ConnectorName>;

/**
 * Current indexing/processing status:
 *
 * @remarks
 * - NOT_STARTED: Awaiting indexing
 * - QUEUED: In indexing queue
 * - IN_PROGRESS: Currently being indexed
 * - COMPLETED: Successfully indexed and searchable
 * - FAILED: Indexing failed (check error details)
 * - PAUSED: Indexing paused by user
 * - FILE_TYPE_NOT_SUPPORTED: Unsupported file format
 * - AUTO_INDEX_OFF: Auto-indexing disabled for this record
 * - EMPTY: File has no extractable content
 * - ENABLE_MULTIMODAL_MODELS: Requires multimodal AI models
 */
export const IndexingStatus = {
  NotStarted: "NOT_STARTED",
  Paused: "PAUSED",
  InProgress: "IN_PROGRESS",
  Completed: "COMPLETED",
  Failed: "FAILED",
  FileTypeNotSupported: "FILE_TYPE_NOT_SUPPORTED",
  AutoIndexOff: "AUTO_INDEX_OFF",
  Empty: "EMPTY",
  EnableMultimodalModels: "ENABLE_MULTIMODAL_MODELS",
  Queued: "QUEUED",
} as const;
/**
 * Current indexing/processing status:
 *
 * @remarks
 * - NOT_STARTED: Awaiting indexing
 * - QUEUED: In indexing queue
 * - IN_PROGRESS: Currently being indexed
 * - COMPLETED: Successfully indexed and searchable
 * - FAILED: Indexing failed (check error details)
 * - PAUSED: Indexing paused by user
 * - FILE_TYPE_NOT_SUPPORTED: Unsupported file format
 * - AUTO_INDEX_OFF: Auto-indexing disabled for this record
 * - EMPTY: File has no extractable content
 * - ENABLE_MULTIMODAL_MODELS: Requires multimodal AI models
 */
export type IndexingStatus = OpenEnum<typeof IndexingStatus>;

/**
 * File-specific metadata (present when recordType is FILE)
 */
export type FileRecord = {
  id?: string | undefined;
  name?: string | undefined;
  extension?: string | undefined;
  mimeType?: string | undefined;
  sizeInBytes?: number | undefined;
  webUrl?: string | undefined;
  path?: string | null | undefined;
  isFile?: boolean | undefined;
};

/**
 * Email-specific metadata (present when recordType is EMAIL)
 */
export type MailRecord = {};

/**
 * Ticket-specific metadata (present when recordType is TICKET)
 */
export type TicketRecord = {};

/**
 * A record represents a single document, file, or content item within a knowledge base.
 *
 * @remarks
 * Records can originate from file uploads or external connectors (Google Drive, OneDrive, etc.).
 */
export type RecordT = {
  /**
   * Unique record identifier (UUID format)
   */
  id?: string | undefined;
  /**
   * Display name of the record
   */
  recordName: string;
  /**
   * Display name (alias for recordName)
   */
  name?: string | undefined;
  /**
   * External storage document ID (links to Storage module)
   */
  externalRecordId?: string | undefined;
  /**
   * Type of content:
   *
   * @remarks
   * - FILE: Uploaded documents (PDF, DOCX, etc.)
   * - WEBPAGE: Web pages crawled or bookmarked
   * - COMMENT: Comments from collaboration tools
   * - MESSAGE: Chat/messaging content (Slack, Teams)
   * - EMAIL: Email messages (Gmail, Outlook)
   * - TICKET: Support tickets (Jira, ServiceNow)
   * - OTHERS: Miscellaneous content types
   */
  recordType: RecordType;
  /**
   * Source of the record:
   *
   * @remarks
   * - UPLOAD: Manually uploaded via API/UI
   * - CONNECTOR: Synced from external connector
   */
  origin: Origin;
  /**
   * ID of the connector that synced this record (null for uploads)
   */
  connectorId?: string | undefined;
  /**
   * Name of the source connector
   */
  connectorName?: ConnectorName | undefined;
  /**
   * Organization ID that owns this record
   */
  orgId: string;
  /**
   * Knowledge base ID containing this record
   */
  kbId?: string | undefined;
  /**
   * Parent folder ID (null if at KB root)
   */
  folderId?: string | null | undefined;
  /**
   * Current version number (increments on updates)
   */
  version: number;
  /**
   * Whether this is the latest version
   */
  isLatestVersion?: boolean | undefined;
  /**
   * Creation timestamp in milliseconds
   */
  createdAtTimestamp?: number | undefined;
  /**
   * Last update timestamp in milliseconds
   */
  updatedAtTimestamp?: number | undefined;
  /**
   * Source creation timestamp (from connector)
   */
  sourceCreatedAtTimestamp?: number | undefined;
  /**
   * Source last modified timestamp (from connector)
   */
  sourceLastModifiedTimestamp?: number | undefined;
  /**
   * Current indexing/processing status:
   *
   * @remarks
   * - NOT_STARTED: Awaiting indexing
   * - QUEUED: In indexing queue
   * - IN_PROGRESS: Currently being indexed
   * - COMPLETED: Successfully indexed and searchable
   * - FAILED: Indexing failed (check error details)
   * - PAUSED: Indexing paused by user
   * - FILE_TYPE_NOT_SUPPORTED: Unsupported file format
   * - AUTO_INDEX_OFF: Auto-indexing disabled for this record
   * - EMPTY: File has no extractable content
   * - ENABLE_MULTIMODAL_MODELS: Requires multimodal AI models
   */
  indexingStatus?: IndexingStatus | undefined;
  /**
   * Soft delete flag
   */
  isDeleted: boolean;
  /**
   * Archive flag for inactive records
   */
  isArchived: boolean;
  /**
   * Direct URL to access the original content
   */
  webUrl?: string | undefined;
  /**
   * MIME type of the file content
   */
  mimeType?: string | undefined;
  /**
   * File size in bytes
   */
  sizeInBytes?: number | undefined;
  /**
   * File extension (without dot)
   */
  extension?: string | undefined;
  /**
   * SHA-256 hash for content deduplication
   */
  sha256Hash?: string | undefined;
  /**
   * Node type identifier
   */
  type?: string | undefined;
  /**
   * File-specific metadata (present when recordType is FILE)
   */
  fileRecord?: FileRecord | null | undefined;
  /**
   * Email-specific metadata (present when recordType is EMAIL)
   */
  mailRecord?: MailRecord | null | undefined;
  /**
   * Ticket-specific metadata (present when recordType is TICKET)
   */
  ticketRecord?: TicketRecord | null | undefined;
};

/** @internal */
export const RecordType$inboundSchema: z.ZodMiniType<RecordType, unknown> =
  openEnums.inboundSchema(RecordType);

/** @internal */
export const Origin$inboundSchema: z.ZodMiniType<Origin, unknown> = openEnums
  .inboundSchema(Origin);

/** @internal */
export const ConnectorName$inboundSchema: z.ZodMiniType<
  ConnectorName,
  unknown
> = openEnums.inboundSchema(ConnectorName);

/** @internal */
export const IndexingStatus$inboundSchema: z.ZodMiniType<
  IndexingStatus,
  unknown
> = openEnums.inboundSchema(IndexingStatus);

/** @internal */
export const FileRecord$inboundSchema: z.ZodMiniType<FileRecord, unknown> = z
  .object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    extension: types.optional(types.string()),
    mimeType: types.optional(types.string()),
    sizeInBytes: types.optional(types.number()),
    webUrl: types.optional(types.string()),
    path: z.optional(z.nullable(types.string())),
    isFile: types.optional(types.boolean()),
  });

export function fileRecordFromJSON(
  jsonString: string,
): SafeParseResult<FileRecord, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FileRecord$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FileRecord' from JSON`,
  );
}

/** @internal */
export const MailRecord$inboundSchema: z.ZodMiniType<MailRecord, unknown> = z
  .object({});

export function mailRecordFromJSON(
  jsonString: string,
): SafeParseResult<MailRecord, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MailRecord$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MailRecord' from JSON`,
  );
}

/** @internal */
export const TicketRecord$inboundSchema: z.ZodMiniType<TicketRecord, unknown> =
  z.object({});

export function ticketRecordFromJSON(
  jsonString: string,
): SafeParseResult<TicketRecord, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TicketRecord$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TicketRecord' from JSON`,
  );
}

/** @internal */
export const RecordT$inboundSchema: z.ZodMiniType<RecordT, unknown> = z.object({
  id: types.optional(types.string()),
  recordName: types.string(),
  name: types.optional(types.string()),
  externalRecordId: types.optional(types.string()),
  recordType: RecordType$inboundSchema,
  origin: Origin$inboundSchema,
  connectorId: types.optional(types.string()),
  connectorName: types.optional(ConnectorName$inboundSchema),
  orgId: types.string(),
  kbId: types.optional(types.string()),
  folderId: z.optional(z.nullable(types.string())),
  version: z._default(types.number(), 0),
  isLatestVersion: types.optional(types.boolean()),
  createdAtTimestamp: types.optional(types.number()),
  updatedAtTimestamp: types.optional(types.number()),
  sourceCreatedAtTimestamp: types.optional(types.number()),
  sourceLastModifiedTimestamp: types.optional(types.number()),
  indexingStatus: types.optional(IndexingStatus$inboundSchema),
  isDeleted: z._default(types.boolean(), false),
  isArchived: z._default(types.boolean(), false),
  webUrl: types.optional(types.string()),
  mimeType: types.optional(types.string()),
  sizeInBytes: types.optional(types.number()),
  extension: types.optional(types.string()),
  sha256Hash: types.optional(types.string()),
  type: types.optional(types.string()),
  fileRecord: z.optional(z.nullable(z.lazy(() => FileRecord$inboundSchema))),
  mailRecord: z.optional(z.nullable(z.lazy(() => MailRecord$inboundSchema))),
  ticketRecord: z.optional(
    z.nullable(z.lazy(() => TicketRecord$inboundSchema)),
  ),
});

export function recordFromJSON(
  jsonString: string,
): SafeParseResult<RecordT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RecordT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RecordT' from JSON`,
  );
}
