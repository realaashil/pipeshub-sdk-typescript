/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

/**
 * Type of content:
 *
 * @remarks
 * - FILE: Uploaded documents (PDF, DOCX, etc.)
 * - WEBPAGE: Web pages crawled or bookmarked
 * - COMMENT: Comments from collaboration tools
 * - MESSAGE: Chat/messaging content (Slack, Teams)
 * - EMAIL: Email messages (Gmail, Outlook)
 * - TICKET: Support tickets (Jira, ServiceNow)
 * - OTHERS: Miscellaneous content types
 */
export const RecordType = {
  File: "FILE",
  Webpage: "WEBPAGE",
  Comment: "COMMENT",
  Message: "MESSAGE",
  Email: "EMAIL",
  Ticket: "TICKET",
  Others: "OTHERS",
} as const;
/**
 * Type of content:
 *
 * @remarks
 * - FILE: Uploaded documents (PDF, DOCX, etc.)
 * - WEBPAGE: Web pages crawled or bookmarked
 * - COMMENT: Comments from collaboration tools
 * - MESSAGE: Chat/messaging content (Slack, Teams)
 * - EMAIL: Email messages (Gmail, Outlook)
 * - TICKET: Support tickets (Jira, ServiceNow)
 * - OTHERS: Miscellaneous content types
 */
export type RecordType = OpenEnum<typeof RecordType>;

/**
 * Source of the record:
 *
 * @remarks
 * - UPLOAD: Manually uploaded via API/UI
 * - CONNECTOR: Synced from external connector
 */
export const Origin = {
  Upload: "UPLOAD",
  Connector: "CONNECTOR",
} as const;
/**
 * Source of the record:
 *
 * @remarks
 * - UPLOAD: Manually uploaded via API/UI
 * - CONNECTOR: Synced from external connector
 */
export type Origin = OpenEnum<typeof Origin>;

/**
 * Name of the source connector
 */
export const ConnectorName = {
  Onedrive: "ONEDRIVE",
  GoogleDrive: "GOOGLE_DRIVE",
  Confluence: "CONFLUENCE",
  Jira: "JIRA",
  Slack: "SLACK",
  SharepointOnline: "SHAREPOINT_ONLINE",
  Gmail: "GMAIL",
  Dropbox: "DROPBOX",
  Outlook: "OUTLOOK",
  Servicenow: "SERVICENOW",
  Bookstack: "BOOKSTACK",
  Web: "WEB",
} as const;
/**
 * Name of the source connector
 */
export type ConnectorName = OpenEnum<typeof ConnectorName>;

/**
 * Current indexing/processing status:
 *
 * @remarks
 * - NOT_STARTED: Awaiting indexing
 * - QUEUED: In indexing queue
 * - IN_PROGRESS: Currently being indexed
 * - COMPLETED: Successfully indexed and searchable
 * - FAILED: Indexing failed (check error details)
 * - PAUSED: Indexing paused by user
 * - FILE_TYPE_NOT_SUPPORTED: Unsupported file format
 * - AUTO_INDEX_OFF: Auto-indexing disabled for this record
 * - EMPTY: File has no extractable content
 * - ENABLE_MULTIMODAL_MODELS: Requires multimodal AI models
 */
export const IndexingStatus = {
  NotStarted: "NOT_STARTED",
  Paused: "PAUSED",
  InProgress: "IN_PROGRESS",
  Completed: "COMPLETED",
  Failed: "FAILED",
  FileTypeNotSupported: "FILE_TYPE_NOT_SUPPORTED",
  AutoIndexOff: "AUTO_INDEX_OFF",
  Empty: "EMPTY",
  EnableMultimodalModels: "ENABLE_MULTIMODAL_MODELS",
  Queued: "QUEUED",
} as const;
/**
 * Current indexing/processing status:
 *
 * @remarks
 * - NOT_STARTED: Awaiting indexing
 * - QUEUED: In indexing queue
 * - IN_PROGRESS: Currently being indexed
 * - COMPLETED: Successfully indexed and searchable
 * - FAILED: Indexing failed (check error details)
 * - PAUSED: Indexing paused by user
 * - FILE_TYPE_NOT_SUPPORTED: Unsupported file format
 * - AUTO_INDEX_OFF: Auto-indexing disabled for this record
 * - EMPTY: File has no extractable content
 * - ENABLE_MULTIMODAL_MODELS: Requires multimodal AI models
 */
export type IndexingStatus = OpenEnum<typeof IndexingStatus>;

/**
 * A record represents a single document, file, or content item within a knowledge base.
 *
 * @remarks
 * Records can originate from file uploads or external connectors (Google Drive, OneDrive, etc.).
 */
export type RecordT = {
  /**
   * Unique record identifier (UUID format)
   */
  key?: string | undefined;
  /**
   * Display name of the record
   */
  recordName: string;
  /**
   * External storage document ID (links to Storage module)
   */
  externalRecordId?: string | undefined;
  /**
   * Type of content:
   *
   * @remarks
   * - FILE: Uploaded documents (PDF, DOCX, etc.)
   * - WEBPAGE: Web pages crawled or bookmarked
   * - COMMENT: Comments from collaboration tools
   * - MESSAGE: Chat/messaging content (Slack, Teams)
   * - EMAIL: Email messages (Gmail, Outlook)
   * - TICKET: Support tickets (Jira, ServiceNow)
   * - OTHERS: Miscellaneous content types
   */
  recordType: RecordType;
  /**
   * Source of the record:
   *
   * @remarks
   * - UPLOAD: Manually uploaded via API/UI
   * - CONNECTOR: Synced from external connector
   */
  origin: Origin;
  /**
   * ID of the connector that synced this record (null for uploads)
   */
  connectorId?: string | undefined;
  /**
   * Name of the source connector
   */
  connectorName?: ConnectorName | undefined;
  /**
   * Organization ID that owns this record
   */
  orgId: string;
  /**
   * Knowledge base ID containing this record
   */
  kbId?: string | undefined;
  /**
   * Parent folder ID (null if at KB root)
   */
  folderId?: string | undefined;
  /**
   * Current version number (increments on updates)
   */
  version: number;
  /**
   * Creation timestamp in milliseconds
   */
  createdAtTimestamp?: number | undefined;
  /**
   * Last update timestamp in milliseconds
   */
  updatedAtTimestamp?: number | undefined;
  /**
   * Current indexing/processing status:
   *
   * @remarks
   * - NOT_STARTED: Awaiting indexing
   * - QUEUED: In indexing queue
   * - IN_PROGRESS: Currently being indexed
   * - COMPLETED: Successfully indexed and searchable
   * - FAILED: Indexing failed (check error details)
   * - PAUSED: Indexing paused by user
   * - FILE_TYPE_NOT_SUPPORTED: Unsupported file format
   * - AUTO_INDEX_OFF: Auto-indexing disabled for this record
   * - EMPTY: File has no extractable content
   * - ENABLE_MULTIMODAL_MODELS: Requires multimodal AI models
   */
  indexingStatus?: IndexingStatus | undefined;
  /**
   * Soft delete flag
   */
  isDeleted: boolean;
  /**
   * Archive flag for inactive records
   */
  isArchived: boolean;
  /**
   * Direct URL to access the original content
   */
  webUrl?: string | undefined;
  /**
   * MIME type of the file content
   */
  mimeType?: string | undefined;
  /**
   * File size in bytes
   */
  sizeInBytes?: number | undefined;
  /**
   * File extension (without dot)
   */
  extension?: string | undefined;
  /**
   * SHA-256 hash for content deduplication
   */
  sha256Hash?: string | undefined;
};

/** @internal */
export const RecordType$inboundSchema: z.ZodMiniType<RecordType, unknown> =
  openEnums.inboundSchema(RecordType);

/** @internal */
export const Origin$inboundSchema: z.ZodMiniType<Origin, unknown> = openEnums
  .inboundSchema(Origin);

/** @internal */
export const ConnectorName$inboundSchema: z.ZodMiniType<
  ConnectorName,
  unknown
> = openEnums.inboundSchema(ConnectorName);

/** @internal */
export const IndexingStatus$inboundSchema: z.ZodMiniType<
  IndexingStatus,
  unknown
> = openEnums.inboundSchema(IndexingStatus);

/** @internal */
export const RecordT$inboundSchema: z.ZodMiniType<RecordT, unknown> = z.pipe(
  z.object({
    _key: types.optional(types.string()),
    recordName: types.string(),
    externalRecordId: types.optional(types.string()),
    recordType: RecordType$inboundSchema,
    origin: Origin$inboundSchema,
    connectorId: types.optional(types.string()),
    connectorName: types.optional(ConnectorName$inboundSchema),
    orgId: types.string(),
    kbId: types.optional(types.string()),
    folderId: types.optional(types.string()),
    version: z._default(types.number(), 0),
    createdAtTimestamp: types.optional(types.number()),
    updatedAtTimestamp: types.optional(types.number()),
    indexingStatus: types.optional(IndexingStatus$inboundSchema),
    isDeleted: z._default(types.boolean(), false),
    isArchived: z._default(types.boolean(), false),
    webUrl: types.optional(types.string()),
    mimeType: types.optional(types.string()),
    sizeInBytes: types.optional(types.number()),
    extension: types.optional(types.string()),
    sha256Hash: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "_key": "key",
    });
  }),
);

export function recordFromJSON(
  jsonString: string,
): SafeParseResult<RecordT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RecordT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RecordT' from JSON`,
  );
}
