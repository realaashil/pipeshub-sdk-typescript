/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

/**
 * Filter input type
 */
export const FilterOptionsType = {
  Select: "select",
  Multiselect: "multiselect",
  Text: "text",
  Boolean: "boolean",
} as const;
/**
 * Filter input type
 */
export type FilterOptionsType = OpenEnum<typeof FilterOptionsType>;

export type Option = {
  id?: string | undefined;
  value?: string | undefined;
  label?: string | undefined;
};

export type Filter = {
  /**
   * Filter field key
   */
  key?: string | undefined;
  /**
   * Display label
   */
  label?: string | undefined;
  /**
   * Filter input type
   */
  type?: FilterOptionsType | undefined;
  options?: Array<Option> | undefined;
  /**
   * Whether options are loaded dynamically
   */
  dynamic?: boolean | undefined;
};

/**
 * Available filter options for a connector
 */
export type FilterOptions = {
  filters?: Array<Filter> | undefined;
};

/** @internal */
export const FilterOptionsType$inboundSchema: z.ZodMiniType<
  FilterOptionsType,
  unknown
> = openEnums.inboundSchema(FilterOptionsType);

/** @internal */
export const Option$inboundSchema: z.ZodMiniType<Option, unknown> = z.object({
  id: types.optional(types.string()),
  value: types.optional(types.string()),
  label: types.optional(types.string()),
});

export function optionFromJSON(
  jsonString: string,
): SafeParseResult<Option, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Option$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Option' from JSON`,
  );
}

/** @internal */
export const Filter$inboundSchema: z.ZodMiniType<Filter, unknown> = z.object({
  key: types.optional(types.string()),
  label: types.optional(types.string()),
  type: types.optional(FilterOptionsType$inboundSchema),
  options: types.optional(z.array(z.lazy(() => Option$inboundSchema))),
  dynamic: types.optional(types.boolean()),
});

export function filterFromJSON(
  jsonString: string,
): SafeParseResult<Filter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Filter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Filter' from JSON`,
  );
}

/** @internal */
export const FilterOptions$inboundSchema: z.ZodMiniType<
  FilterOptions,
  unknown
> = z.object({
  filters: types.optional(z.array(z.lazy(() => Filter$inboundSchema))),
});

export function filterOptionsFromJSON(
  jsonString: string,
): SafeParseResult<FilterOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FilterOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FilterOptions' from JSON`,
  );
}
