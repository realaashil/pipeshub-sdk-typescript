/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";
import * as models from "../index.js";

/**
 * Field to sort by
 */
export const ListKnowledgeBasesSortBy = {
  Name: "name",
  CreatedAtTimestamp: "createdAtTimestamp",
  UpdatedAtTimestamp: "updatedAtTimestamp",
  UserRole: "userRole",
} as const;
/**
 * Field to sort by
 */
export type ListKnowledgeBasesSortBy = ClosedEnum<
  typeof ListKnowledgeBasesSortBy
>;

/**
 * Sort direction
 */
export const ListKnowledgeBasesSortOrder = {
  Asc: "asc",
  Desc: "desc",
} as const;
/**
 * Sort direction
 */
export type ListKnowledgeBasesSortOrder = ClosedEnum<
  typeof ListKnowledgeBasesSortOrder
>;

export type ListKnowledgeBasesRequest = {
  /**
   * Page number (1-indexed)
   */
  page?: number | undefined;
  /**
   * Results per page (max 100)
   */
  limit?: number | undefined;
  /**
   * Search query for KB names (max 1000 chars)
   */
  search?: string | undefined;
  /**
   * Filter by permission roles (comma-separated)
   */
  permissions?: string | undefined;
  /**
   * Field to sort by
   */
  sortBy?: ListKnowledgeBasesSortBy | undefined;
  /**
   * Sort direction
   */
  sortOrder?: ListKnowledgeBasesSortOrder | undefined;
};

export type ListKnowledgeBasesPagination = {
  /**
   * Current page number
   */
  page?: number | undefined;
  /**
   * Items per page
   */
  limit?: number | undefined;
  /**
   * Total number of items
   */
  totalCount?: number | undefined;
  /**
   * Total number of pages
   */
  totalPages?: number | undefined;
  /**
   * Whether there is a next page
   */
  hasNext?: boolean | undefined;
  /**
   * Whether there is a previous page
   */
  hasPrev?: boolean | undefined;
};

export type Applied = {};

export type Available = {};

/**
 * Applied and available filters
 */
export type ListKnowledgeBasesFilters = {
  applied?: Applied | undefined;
  available?: Available | undefined;
};

/**
 * Successful operation
 */
export type ListKnowledgeBasesResponse = {
  knowledgeBases?: Array<models.KnowledgeBase> | undefined;
  pagination?: ListKnowledgeBasesPagination | undefined;
  /**
   * Applied and available filters
   */
  filters?: ListKnowledgeBasesFilters | undefined;
};

/** @internal */
export const ListKnowledgeBasesSortBy$outboundSchema: z.ZodMiniEnum<
  typeof ListKnowledgeBasesSortBy
> = z.enum(ListKnowledgeBasesSortBy);

/** @internal */
export const ListKnowledgeBasesSortOrder$outboundSchema: z.ZodMiniEnum<
  typeof ListKnowledgeBasesSortOrder
> = z.enum(ListKnowledgeBasesSortOrder);

/** @internal */
export type ListKnowledgeBasesRequest$Outbound = {
  page: number;
  limit: number;
  search?: string | undefined;
  permissions?: string | undefined;
  sortBy: string;
  sortOrder: string;
};

/** @internal */
export const ListKnowledgeBasesRequest$outboundSchema: z.ZodMiniType<
  ListKnowledgeBasesRequest$Outbound,
  ListKnowledgeBasesRequest
> = z.object({
  page: z._default(z.int(), 1),
  limit: z._default(z.int(), 20),
  search: z.optional(z.string()),
  permissions: z.optional(z.string()),
  sortBy: z._default(ListKnowledgeBasesSortBy$outboundSchema, "name"),
  sortOrder: z._default(ListKnowledgeBasesSortOrder$outboundSchema, "asc"),
});

export function listKnowledgeBasesRequestToJSON(
  listKnowledgeBasesRequest: ListKnowledgeBasesRequest,
): string {
  return JSON.stringify(
    ListKnowledgeBasesRequest$outboundSchema.parse(listKnowledgeBasesRequest),
  );
}

/** @internal */
export const ListKnowledgeBasesPagination$inboundSchema: z.ZodMiniType<
  ListKnowledgeBasesPagination,
  unknown
> = z.object({
  page: types.optional(types.number()),
  limit: types.optional(types.number()),
  totalCount: types.optional(types.number()),
  totalPages: types.optional(types.number()),
  hasNext: types.optional(types.boolean()),
  hasPrev: types.optional(types.boolean()),
});

export function listKnowledgeBasesPaginationFromJSON(
  jsonString: string,
): SafeParseResult<ListKnowledgeBasesPagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListKnowledgeBasesPagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListKnowledgeBasesPagination' from JSON`,
  );
}

/** @internal */
export const Applied$inboundSchema: z.ZodMiniType<Applied, unknown> = z.object(
  {},
);

export function appliedFromJSON(
  jsonString: string,
): SafeParseResult<Applied, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Applied$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Applied' from JSON`,
  );
}

/** @internal */
export const Available$inboundSchema: z.ZodMiniType<Available, unknown> = z
  .object({});

export function availableFromJSON(
  jsonString: string,
): SafeParseResult<Available, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Available$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Available' from JSON`,
  );
}

/** @internal */
export const ListKnowledgeBasesFilters$inboundSchema: z.ZodMiniType<
  ListKnowledgeBasesFilters,
  unknown
> = z.object({
  applied: types.optional(z.lazy(() => Applied$inboundSchema)),
  available: types.optional(z.lazy(() => Available$inboundSchema)),
});

export function listKnowledgeBasesFiltersFromJSON(
  jsonString: string,
): SafeParseResult<ListKnowledgeBasesFilters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListKnowledgeBasesFilters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListKnowledgeBasesFilters' from JSON`,
  );
}

/** @internal */
export const ListKnowledgeBasesResponse$inboundSchema: z.ZodMiniType<
  ListKnowledgeBasesResponse,
  unknown
> = z.object({
  knowledgeBases: types.optional(z.array(models.KnowledgeBase$inboundSchema)),
  pagination: types.optional(
    z.lazy(() => ListKnowledgeBasesPagination$inboundSchema),
  ),
  filters: types.optional(
    z.lazy(() => ListKnowledgeBasesFilters$inboundSchema),
  ),
});

export function listKnowledgeBasesResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListKnowledgeBasesResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListKnowledgeBasesResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListKnowledgeBasesResponse' from JSON`,
  );
}
