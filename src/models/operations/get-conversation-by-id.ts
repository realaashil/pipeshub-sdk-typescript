/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";
import * as models from "../index.js";

/**
 * Sort direction
 */
export const GetConversationByIdSortOrder = {
  Asc: "asc",
  Desc: "desc",
} as const;
/**
 * Sort direction
 */
export type GetConversationByIdSortOrder = ClosedEnum<
  typeof GetConversationByIdSortOrder
>;

export type GetConversationByIdRequest = {
  /**
   * Unique conversation identifier
   */
  conversationId: string;
  /**
   * Page number for message pagination
   */
  page?: number | undefined;
  /**
   * Number of messages per page
   */
  limit?: number | undefined;
  /**
   * Field to sort messages by
   */
  sortBy?: string | undefined;
  /**
   * Sort direction
   */
  sortOrder?: GetConversationByIdSortOrder | undefined;
};

/**
 * Current status of the conversation:
 *
 * @remarks
 * <ul>
 * <li><code>INPROGRESS</code> - AI is processing</li>
 * <li><code>COMPLETED</code> - Response ready</li>
 * <li><code>FAILED</code> - Error occurred</li>
 * </ul>
 */
export const GetConversationByIdStatus = {
  Inprogress: "INPROGRESS",
  Completed: "COMPLETED",
  Failed: "FAILED",
} as const;
/**
 * Current status of the conversation:
 *
 * @remarks
 * <ul>
 * <li><code>INPROGRESS</code> - AI is processing</li>
 * <li><code>COMPLETED</code> - Response ready</li>
 * <li><code>FAILED</code> - Error occurred</li>
 * </ul>
 */
export type GetConversationByIdStatus = OpenEnum<
  typeof GetConversationByIdStatus
>;

/**
 * AI model configuration used
 */
export type ModelInfo = {
  modelKey?: string | undefined;
  modelName?: string | undefined;
  modelProvider?: string | undefined;
  chatMode?: string | undefined;
};

export const GetConversationByIdAccessLevel = {
  Read: "read",
  Write: "write",
} as const;
export type GetConversationByIdAccessLevel = OpenEnum<
  typeof GetConversationByIdAccessLevel
>;

export type GetConversationByIdSharedWith = {
  userId?: string | undefined;
  accessLevel?: GetConversationByIdAccessLevel | undefined;
};

export type GetConversationByIdPagination = {
  page?: number | undefined;
  limit?: number | undefined;
  totalMessages?: number | undefined;
  totalPages?: number | undefined;
};

/**
 * A conversation represents a chat session between a user and the AI.
 *
 * @remarks
 * Conversations maintain context across multiple messages and can be
 * shared, archived, and organized.
 */
export type GetConversationByIdResponse = {
  /**
   * Unique conversation identifier
   */
  id?: string | undefined;
  /**
   * ID of the user who owns this conversation
   */
  userId?: string | undefined;
  /**
   * Organization this conversation belongs to
   */
  orgId?: string | undefined;
  /**
   * Conversation title, auto-generated from first query
   *
   * @remarks
   * or manually updated
   */
  title?: string | undefined;
  /**
   * User who started the conversation
   */
  initiator?: string | undefined;
  /**
   * All messages in this conversation
   */
  messages?: Array<models.Message> | undefined;
  /**
   * Current status of the conversation:
   *
   * @remarks
   * <ul>
   * <li><code>INPROGRESS</code> - AI is processing</li>
   * <li><code>COMPLETED</code> - Response ready</li>
   * <li><code>FAILED</code> - Error occurred</li>
   * </ul>
   */
  status?: GetConversationByIdStatus | undefined;
  /**
   * Error description if status is FAILED
   */
  failReason?: string | undefined;
  /**
   * AI model configuration used
   */
  modelInfo?: ModelInfo | undefined;
  /**
   * Whether this conversation is shared with others
   */
  isShared: boolean;
  /**
   * Shareable link if conversation is shared
   */
  shareLink?: string | undefined;
  /**
   * Users this conversation is shared with
   */
  sharedWith?: Array<GetConversationByIdSharedWith> | undefined;
  /**
   * Whether this conversation is archived
   */
  isArchived: boolean;
  /**
   * User who archived this conversation
   */
  archivedBy?: string | undefined;
  /**
   * Unix timestamp of last activity
   */
  lastActivityAt?: number | undefined;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
  pagination?: GetConversationByIdPagination | undefined;
};

/** @internal */
export const GetConversationByIdSortOrder$outboundSchema: z.ZodMiniEnum<
  typeof GetConversationByIdSortOrder
> = z.enum(GetConversationByIdSortOrder);

/** @internal */
export type GetConversationByIdRequest$Outbound = {
  conversationId: string;
  page: number;
  limit: number;
  sortBy: string;
  sortOrder: string;
};

/** @internal */
export const GetConversationByIdRequest$outboundSchema: z.ZodMiniType<
  GetConversationByIdRequest$Outbound,
  GetConversationByIdRequest
> = z.object({
  conversationId: z.string(),
  page: z._default(z.int(), 1),
  limit: z._default(z.int(), 10),
  sortBy: z._default(z.string(), "createdAt"),
  sortOrder: z._default(GetConversationByIdSortOrder$outboundSchema, "desc"),
});

export function getConversationByIdRequestToJSON(
  getConversationByIdRequest: GetConversationByIdRequest,
): string {
  return JSON.stringify(
    GetConversationByIdRequest$outboundSchema.parse(getConversationByIdRequest),
  );
}

/** @internal */
export const GetConversationByIdStatus$inboundSchema: z.ZodMiniType<
  GetConversationByIdStatus,
  unknown
> = openEnums.inboundSchema(GetConversationByIdStatus);

/** @internal */
export const ModelInfo$inboundSchema: z.ZodMiniType<ModelInfo, unknown> = z
  .object({
    modelKey: types.optional(types.string()),
    modelName: types.optional(types.string()),
    modelProvider: types.optional(types.string()),
    chatMode: types.optional(types.string()),
  });

export function modelInfoFromJSON(
  jsonString: string,
): SafeParseResult<ModelInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelInfo' from JSON`,
  );
}

/** @internal */
export const GetConversationByIdAccessLevel$inboundSchema: z.ZodMiniType<
  GetConversationByIdAccessLevel,
  unknown
> = openEnums.inboundSchema(GetConversationByIdAccessLevel);

/** @internal */
export const GetConversationByIdSharedWith$inboundSchema: z.ZodMiniType<
  GetConversationByIdSharedWith,
  unknown
> = z.object({
  userId: types.optional(types.string()),
  accessLevel: types.optional(GetConversationByIdAccessLevel$inboundSchema),
});

export function getConversationByIdSharedWithFromJSON(
  jsonString: string,
): SafeParseResult<GetConversationByIdSharedWith, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetConversationByIdSharedWith$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetConversationByIdSharedWith' from JSON`,
  );
}

/** @internal */
export const GetConversationByIdPagination$inboundSchema: z.ZodMiniType<
  GetConversationByIdPagination,
  unknown
> = z.object({
  page: types.optional(types.number()),
  limit: types.optional(types.number()),
  totalMessages: types.optional(types.number()),
  totalPages: types.optional(types.number()),
});

export function getConversationByIdPaginationFromJSON(
  jsonString: string,
): SafeParseResult<GetConversationByIdPagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetConversationByIdPagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetConversationByIdPagination' from JSON`,
  );
}

/** @internal */
export const GetConversationByIdResponse$inboundSchema: z.ZodMiniType<
  GetConversationByIdResponse,
  unknown
> = z.pipe(
  z.object({
    _id: types.optional(types.string()),
    userId: types.optional(types.string()),
    orgId: types.optional(types.string()),
    title: types.optional(types.string()),
    initiator: types.optional(types.string()),
    messages: types.optional(z.array(models.Message$inboundSchema)),
    status: types.optional(GetConversationByIdStatus$inboundSchema),
    failReason: types.optional(types.string()),
    modelInfo: types.optional(z.lazy(() => ModelInfo$inboundSchema)),
    isShared: z._default(types.boolean(), false),
    shareLink: types.optional(types.string()),
    sharedWith: types.optional(
      z.array(z.lazy(() => GetConversationByIdSharedWith$inboundSchema)),
    ),
    isArchived: z._default(types.boolean(), false),
    archivedBy: types.optional(types.string()),
    lastActivityAt: types.optional(types.number()),
    createdAt: types.optional(types.date()),
    updatedAt: types.optional(types.date()),
    pagination: types.optional(
      z.lazy(() => GetConversationByIdPagination$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "_id": "id",
    });
  }),
);

export function getConversationByIdResponseFromJSON(
  jsonString: string,
): SafeParseResult<GetConversationByIdResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetConversationByIdResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetConversationByIdResponse' from JSON`,
  );
}
