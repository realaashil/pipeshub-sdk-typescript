/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";
import * as models from "../index.js";

/**
 * Request payload
 */
export type ScheduleCrawlingJobRequestBody = {
  /**
   * Schedule configuration for crawling jobs. The structure varies based on <code>scheduleType</code>.<br><br>
   *
   * @remarks
   * <b>Schedule Type Configurations:</b><br>
   * <ul>
   * <li><b>hourly:</b> <code>minute</code>, <code>interval</code> (optional)</li>
   * <li><b>daily:</b> <code>hour</code>, <code>minute</code></li>
   * <li><b>weekly:</b> <code>daysOfWeek</code>, <code>hour</code>, <code>minute</code></li>
   * <li><b>monthly:</b> <code>dayOfMonth</code>, <code>hour</code>, <code>minute</code></li>
   * <li><b>custom:</b> <code>cronExpression</code>, <code>description</code> (optional)</li>
   * <li><b>once:</b> <code>scheduledTime</code></li>
   * </ul>
   */
  scheduleConfig: models.ScheduleConfig;
  /**
   * Job priority (1=highest, 10=lowest). Higher priority jobs are processed first.
   */
  priority?: number | undefined;
  /**
   * Maximum number of retry attempts on failure
   */
  maxRetries?: number | undefined;
  /**
   * Job timeout in milliseconds (default 5 minutes)
   */
  timeout?: number | undefined;
};

export type ScheduleCrawlingJobRequest = {
  /**
   * Connector type identifier (e.g., "drive", "onedrive", "slack", "jira")
   */
  connector: string;
  /**
   * Unique identifier of the connector instance (MongoDB ObjectId)
   */
  connectorId: string;
  /**
   * Request payload
   */
  body: ScheduleCrawlingJobRequestBody;
};

export type ScheduleCrawlingJobData = {
  /**
   * Unique job ID assigned by BullMQ
   */
  jobId?: string | undefined;
  connector?: string | undefined;
  connectorId?: string | undefined;
  /**
   * Schedule configuration for crawling jobs. The structure varies based on <code>scheduleType</code>.<br><br>
   *
   * @remarks
   * <b>Schedule Type Configurations:</b><br>
   * <ul>
   * <li><b>hourly:</b> <code>minute</code>, <code>interval</code> (optional)</li>
   * <li><b>daily:</b> <code>hour</code>, <code>minute</code></li>
   * <li><b>weekly:</b> <code>daysOfWeek</code>, <code>hour</code>, <code>minute</code></li>
   * <li><b>monthly:</b> <code>dayOfMonth</code>, <code>hour</code>, <code>minute</code></li>
   * <li><b>custom:</b> <code>cronExpression</code>, <code>description</code> (optional)</li>
   * <li><b>once:</b> <code>scheduledTime</code></li>
   * </ul>
   */
  scheduleConfig?: models.ScheduleConfig | undefined;
  scheduledAt?: Date | undefined;
};

/**
 * Crawling job scheduled successfully
 */
export type ScheduleCrawlingJobResponse = {
  success?: boolean | undefined;
  message?: string | undefined;
  data?: ScheduleCrawlingJobData | undefined;
};

/** @internal */
export type ScheduleCrawlingJobRequestBody$Outbound = {
  scheduleConfig: models.ScheduleConfig$Outbound;
  priority: number;
  maxRetries: number;
  timeout: number;
};

/** @internal */
export const ScheduleCrawlingJobRequestBody$outboundSchema: z.ZodMiniType<
  ScheduleCrawlingJobRequestBody$Outbound,
  ScheduleCrawlingJobRequestBody
> = z.object({
  scheduleConfig: models.ScheduleConfig$outboundSchema,
  priority: z._default(z.int(), 5),
  maxRetries: z._default(z.int(), 3),
  timeout: z._default(z.int(), 300000),
});

export function scheduleCrawlingJobRequestBodyToJSON(
  scheduleCrawlingJobRequestBody: ScheduleCrawlingJobRequestBody,
): string {
  return JSON.stringify(
    ScheduleCrawlingJobRequestBody$outboundSchema.parse(
      scheduleCrawlingJobRequestBody,
    ),
  );
}

/** @internal */
export type ScheduleCrawlingJobRequest$Outbound = {
  connector: string;
  connectorId: string;
  body: ScheduleCrawlingJobRequestBody$Outbound;
};

/** @internal */
export const ScheduleCrawlingJobRequest$outboundSchema: z.ZodMiniType<
  ScheduleCrawlingJobRequest$Outbound,
  ScheduleCrawlingJobRequest
> = z.object({
  connector: z.string(),
  connectorId: z.string(),
  body: z.lazy(() => ScheduleCrawlingJobRequestBody$outboundSchema),
});

export function scheduleCrawlingJobRequestToJSON(
  scheduleCrawlingJobRequest: ScheduleCrawlingJobRequest,
): string {
  return JSON.stringify(
    ScheduleCrawlingJobRequest$outboundSchema.parse(scheduleCrawlingJobRequest),
  );
}

/** @internal */
export const ScheduleCrawlingJobData$inboundSchema: z.ZodMiniType<
  ScheduleCrawlingJobData,
  unknown
> = z.object({
  jobId: types.optional(types.string()),
  connector: types.optional(types.string()),
  connectorId: types.optional(types.string()),
  scheduleConfig: types.optional(models.ScheduleConfig$inboundSchema),
  scheduledAt: types.optional(types.date()),
});

export function scheduleCrawlingJobDataFromJSON(
  jsonString: string,
): SafeParseResult<ScheduleCrawlingJobData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ScheduleCrawlingJobData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ScheduleCrawlingJobData' from JSON`,
  );
}

/** @internal */
export const ScheduleCrawlingJobResponse$inboundSchema: z.ZodMiniType<
  ScheduleCrawlingJobResponse,
  unknown
> = z.object({
  success: types.optional(types.boolean()),
  message: types.optional(types.string()),
  data: types.optional(z.lazy(() => ScheduleCrawlingJobData$inboundSchema)),
});

export function scheduleCrawlingJobResponseFromJSON(
  jsonString: string,
): SafeParseResult<ScheduleCrawlingJobResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ScheduleCrawlingJobResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ScheduleCrawlingJobResponse' from JSON`,
  );
}
