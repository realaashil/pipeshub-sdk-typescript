/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { safeParse } from "../../lib/schemas.js";
import { blobLikeSchema } from "../../types/blobs.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";
import * as models from "../index.js";

export type UpdateRecordFile = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

/**
 * Request payload
 */
export type UpdateRecordRequestBody = {
  /**
   * New name for the record
   */
  recordName?: string | undefined;
  /**
   * Replacement file content
   */
  file?: UpdateRecordFile | Blob | undefined;
};

export type UpdateRecordRequest = {
  /**
   * Record ID
   */
  recordId: string;
  /**
   * Request payload
   */
  body?: UpdateRecordRequestBody | undefined;
};

/**
 * Record updated successfully
 */
export type UpdateRecordResponse = {
  success?: boolean | undefined;
  message?: string | undefined;
  /**
   * A record represents a single document, file, or content item within a knowledge base.
   *
   * @remarks
   * Records can originate from file uploads or external connectors (Google Drive, OneDrive, etc.).
   */
  record?: models.RecordT | undefined;
};

/** @internal */
export type UpdateRecordFile$Outbound = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

/** @internal */
export const UpdateRecordFile$outboundSchema: z.ZodMiniType<
  UpdateRecordFile$Outbound,
  UpdateRecordFile
> = z.object({
  fileName: z.string(),
  content: z.union([
    z.custom<ReadableStream<Uint8Array>>(x => x instanceof ReadableStream),
    z.custom<Blob>(x => x instanceof Blob),
    z.custom<ArrayBuffer>(x => x instanceof ArrayBuffer),
    z.custom<Uint8Array>(x => x instanceof Uint8Array),
  ]),
});

export function updateRecordFileToJSON(
  updateRecordFile: UpdateRecordFile,
): string {
  return JSON.stringify(
    UpdateRecordFile$outboundSchema.parse(updateRecordFile),
  );
}

/** @internal */
export type UpdateRecordRequestBody$Outbound = {
  recordName?: string | undefined;
  file?: UpdateRecordFile$Outbound | Blob | undefined;
};

/** @internal */
export const UpdateRecordRequestBody$outboundSchema: z.ZodMiniType<
  UpdateRecordRequestBody$Outbound,
  UpdateRecordRequestBody
> = z.object({
  recordName: z.optional(z.string()),
  file: z.optional(
    z.union([z.lazy(() => UpdateRecordFile$outboundSchema), blobLikeSchema]),
  ),
});

export function updateRecordRequestBodyToJSON(
  updateRecordRequestBody: UpdateRecordRequestBody,
): string {
  return JSON.stringify(
    UpdateRecordRequestBody$outboundSchema.parse(updateRecordRequestBody),
  );
}

/** @internal */
export type UpdateRecordRequest$Outbound = {
  recordId: string;
  body?: UpdateRecordRequestBody$Outbound | undefined;
};

/** @internal */
export const UpdateRecordRequest$outboundSchema: z.ZodMiniType<
  UpdateRecordRequest$Outbound,
  UpdateRecordRequest
> = z.object({
  recordId: z.string(),
  body: z.optional(z.lazy(() => UpdateRecordRequestBody$outboundSchema)),
});

export function updateRecordRequestToJSON(
  updateRecordRequest: UpdateRecordRequest,
): string {
  return JSON.stringify(
    UpdateRecordRequest$outboundSchema.parse(updateRecordRequest),
  );
}

/** @internal */
export const UpdateRecordResponse$inboundSchema: z.ZodMiniType<
  UpdateRecordResponse,
  unknown
> = z.object({
  success: types.optional(types.boolean()),
  message: types.optional(types.string()),
  record: types.optional(models.RecordT$inboundSchema),
});

export function updateRecordResponseFromJSON(
  jsonString: string,
): SafeParseResult<UpdateRecordResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateRecordResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateRecordResponse' from JSON`,
  );
}
