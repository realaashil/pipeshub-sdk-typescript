/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import {
  DocumentVersion,
  DocumentVersion$inboundSchema,
} from "./document-version.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

/**
 * Default permission level for shared access
 */
export const Permissions = {
  Owner: "owner",
  Editor: "editor",
  Commentator: "commentator",
  Readonly: "readonly",
} as const;
/**
 * Default permission level for shared access
 */
export type Permissions = OpenEnum<typeof Permissions>;

export type CustomMetadatum = {
  key?: string | undefined;
  value?: string | undefined;
};

/**
 * Storage backend where the file is stored
 */
export const StorageVendor = {
  S3: "s3",
  AzureBlob: "azureBlob",
  Local: "local",
} as const;
/**
 * Storage backend where the file is stored
 */
export type StorageVendor = OpenEnum<typeof StorageVendor>;

/**
 * S3-specific storage information (if storageVendor is s3)
 */
export type DocumentS3 = {
  /**
   * S3 object URL
   */
  url?: string | undefined;
};

/**
 * Azure Blob-specific storage information (if storageVendor is azureBlob)
 */
export type DocumentAzureBlob = {
  /**
   * Azure Blob URL
   */
  url?: string | undefined;
};

/**
 * Local storage-specific information (if storageVendor is local)
 */
export type DocumentLocal = {
  /**
   * Local file path
   */
  url?: string | undefined;
  /**
   * Absolute path on filesystem
   */
  localPath?: string | undefined;
};

/**
 * Represents a document stored in PipesHub storage system. Documents can be versioned to maintain complete history of changes. Supports multiple storage backends (S3, Azure Blob, Local).
 *
 * @remarks
 */
export type Document = {
  /**
   * Document unique identifier (MongoDB ObjectId)
   */
  id: string;
  /**
   * Display name of the document
   */
  documentName: string;
  /**
   * Alternative name for search/display purposes
   */
  alternateDocumentName?: string | undefined;
  /**
   * Virtual folder path for organization
   */
  documentPath?: string | undefined;
  /**
   * Whether version control is enabled for this document
   */
  isVersionedFile: boolean;
  /**
   * Organization ID the document belongs to
   */
  orgId: string;
  /**
   * Default permission level for shared access
   */
  permissions?: Permissions | undefined;
  /**
   * User ID who created/uploaded the document
   */
  initiatorUserId?: string | undefined;
  /**
   * File size in bytes
   */
  sizeInBytes?: number | undefined;
  /**
   * MIME type of the document
   */
  mimeType?: string | undefined;
  /**
   * File extension (with leading dot)
   */
  extension?: string | undefined;
  /**
   * Number of times the document has been updated
   */
  mutationCount?: number | undefined;
  /**
   * Complete version history (for versioned documents)
   */
  versionHistory?: Array<DocumentVersion> | undefined;
  /**
   * Custom key-value metadata pairs
   */
  customMetadata?: Array<CustomMetadatum> | undefined;
  /**
   * Tags for categorization and search
   */
  tags?: Array<string> | undefined;
  /**
   * Storage backend where the file is stored
   */
  storageVendor: StorageVendor;
  /**
   * S3-specific storage information (if storageVendor is s3)
   */
  s3?: DocumentS3 | undefined;
  /**
   * Azure Blob-specific storage information (if storageVendor is azureBlob)
   */
  azureBlob?: DocumentAzureBlob | undefined;
  /**
   * Local storage-specific information (if storageVendor is local)
   */
  local?: DocumentLocal | undefined;
  /**
   * Creation timestamp in milliseconds since epoch
   */
  createdAt?: number | undefined;
  /**
   * Last update timestamp in milliseconds since epoch
   */
  updatedAt?: number | undefined;
  /**
   * Whether the document is soft-deleted
   */
  isDeleted: boolean;
  /**
   * User ID who deleted the document
   */
  deletedByUserId?: string | undefined;
};

/** @internal */
export const Permissions$inboundSchema: z.ZodMiniType<Permissions, unknown> =
  openEnums.inboundSchema(Permissions);

/** @internal */
export const CustomMetadatum$inboundSchema: z.ZodMiniType<
  CustomMetadatum,
  unknown
> = z.object({
  key: types.optional(types.string()),
  value: types.optional(types.string()),
});

export function customMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<CustomMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomMetadatum' from JSON`,
  );
}

/** @internal */
export const StorageVendor$inboundSchema: z.ZodMiniType<
  StorageVendor,
  unknown
> = openEnums.inboundSchema(StorageVendor);

/** @internal */
export const DocumentS3$inboundSchema: z.ZodMiniType<DocumentS3, unknown> = z
  .object({
    url: types.optional(types.string()),
  });

export function documentS3FromJSON(
  jsonString: string,
): SafeParseResult<DocumentS3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DocumentS3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DocumentS3' from JSON`,
  );
}

/** @internal */
export const DocumentAzureBlob$inboundSchema: z.ZodMiniType<
  DocumentAzureBlob,
  unknown
> = z.object({
  url: types.optional(types.string()),
});

export function documentAzureBlobFromJSON(
  jsonString: string,
): SafeParseResult<DocumentAzureBlob, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DocumentAzureBlob$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DocumentAzureBlob' from JSON`,
  );
}

/** @internal */
export const DocumentLocal$inboundSchema: z.ZodMiniType<
  DocumentLocal,
  unknown
> = z.object({
  url: types.optional(types.string()),
  localPath: types.optional(types.string()),
});

export function documentLocalFromJSON(
  jsonString: string,
): SafeParseResult<DocumentLocal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DocumentLocal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DocumentLocal' from JSON`,
  );
}

/** @internal */
export const Document$inboundSchema: z.ZodMiniType<Document, unknown> = z.pipe(
  z.object({
    _id: types.string(),
    documentName: types.string(),
    alternateDocumentName: types.optional(types.string()),
    documentPath: types.optional(types.string()),
    isVersionedFile: types.boolean(),
    orgId: types.string(),
    permissions: types.optional(Permissions$inboundSchema),
    initiatorUserId: types.optional(types.string()),
    sizeInBytes: types.optional(types.number()),
    mimeType: types.optional(types.string()),
    extension: types.optional(types.string()),
    mutationCount: types.optional(types.number()),
    versionHistory: types.optional(z.array(DocumentVersion$inboundSchema)),
    customMetadata: types.optional(z.array(z.lazy(() =>
      CustomMetadatum$inboundSchema
    ))),
    tags: types.optional(z.array(types.string())),
    storageVendor: StorageVendor$inboundSchema,
    s3: types.optional(z.lazy(() => DocumentS3$inboundSchema)),
    azureBlob: types.optional(z.lazy(() => DocumentAzureBlob$inboundSchema)),
    local: types.optional(z.lazy(() => DocumentLocal$inboundSchema)),
    createdAt: types.optional(types.number()),
    updatedAt: types.optional(types.number()),
    isDeleted: z._default(types.boolean(), false),
    deletedByUserId: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "_id": "id",
    });
  }),
);

export function documentFromJSON(
  jsonString: string,
): SafeParseResult<Document, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Document$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Document' from JSON`,
  );
}
