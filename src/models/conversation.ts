/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";
import { Message, Message$inboundSchema } from "./message.js";

/**
 * Current status of the conversation:
 *
 * @remarks
 * <ul>
 * <li><code>INPROGRESS</code> - AI is processing</li>
 * <li><code>COMPLETED</code> - Response ready</li>
 * <li><code>FAILED</code> - Error occurred</li>
 * </ul>
 */
export const ConversationStatus = {
  Inprogress: "INPROGRESS",
  Completed: "COMPLETED",
  Failed: "FAILED",
} as const;
/**
 * Current status of the conversation:
 *
 * @remarks
 * <ul>
 * <li><code>INPROGRESS</code> - AI is processing</li>
 * <li><code>COMPLETED</code> - Response ready</li>
 * <li><code>FAILED</code> - Error occurred</li>
 * </ul>
 */
export type ConversationStatus = OpenEnum<typeof ConversationStatus>;

/**
 * AI model configuration used
 */
export type ModelInfo = {
  modelKey?: string | undefined;
  modelName?: string | undefined;
  modelProvider?: string | undefined;
  chatMode?: string | undefined;
};

export const ConversationAccessLevel = {
  Read: "read",
  Write: "write",
} as const;
export type ConversationAccessLevel = OpenEnum<typeof ConversationAccessLevel>;

export type ConversationSharedWith = {
  userId?: string | undefined;
  accessLevel?: ConversationAccessLevel | undefined;
};

/**
 * A conversation represents a chat session between a user and the AI.
 *
 * @remarks
 * Conversations maintain context across multiple messages and can be
 * shared, archived, and organized.
 */
export type Conversation = {
  /**
   * Unique conversation identifier
   */
  id?: string | undefined;
  /**
   * ID of the user who owns this conversation
   */
  userId?: string | undefined;
  /**
   * Organization this conversation belongs to
   */
  orgId?: string | undefined;
  /**
   * Conversation title, auto-generated from first query
   *
   * @remarks
   * or manually updated
   */
  title?: string | undefined;
  /**
   * User who started the conversation
   */
  initiator?: string | undefined;
  /**
   * All messages in this conversation
   */
  messages?: Array<Message> | undefined;
  /**
   * Current status of the conversation:
   *
   * @remarks
   * <ul>
   * <li><code>INPROGRESS</code> - AI is processing</li>
   * <li><code>COMPLETED</code> - Response ready</li>
   * <li><code>FAILED</code> - Error occurred</li>
   * </ul>
   */
  status?: ConversationStatus | undefined;
  /**
   * Error description if status is FAILED
   */
  failReason?: string | undefined;
  /**
   * AI model configuration used
   */
  modelInfo?: ModelInfo | undefined;
  /**
   * Whether this conversation is shared with others
   */
  isShared: boolean;
  /**
   * Shareable link if conversation is shared
   */
  shareLink?: string | undefined;
  /**
   * Users this conversation is shared with
   */
  sharedWith?: Array<ConversationSharedWith> | undefined;
  /**
   * Whether this conversation is archived
   */
  isArchived: boolean;
  /**
   * User who archived this conversation
   */
  archivedBy?: string | undefined;
  /**
   * Unix timestamp of last activity
   */
  lastActivityAt?: number | undefined;
  createdAt?: Date | undefined;
  updatedAt?: Date | undefined;
};

/** @internal */
export const ConversationStatus$inboundSchema: z.ZodMiniType<
  ConversationStatus,
  unknown
> = openEnums.inboundSchema(ConversationStatus);

/** @internal */
export const ModelInfo$inboundSchema: z.ZodMiniType<ModelInfo, unknown> = z
  .object({
    modelKey: types.optional(types.string()),
    modelName: types.optional(types.string()),
    modelProvider: types.optional(types.string()),
    chatMode: types.optional(types.string()),
  });

export function modelInfoFromJSON(
  jsonString: string,
): SafeParseResult<ModelInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelInfo' from JSON`,
  );
}

/** @internal */
export const ConversationAccessLevel$inboundSchema: z.ZodMiniType<
  ConversationAccessLevel,
  unknown
> = openEnums.inboundSchema(ConversationAccessLevel);

/** @internal */
export const ConversationSharedWith$inboundSchema: z.ZodMiniType<
  ConversationSharedWith,
  unknown
> = z.object({
  userId: types.optional(types.string()),
  accessLevel: types.optional(ConversationAccessLevel$inboundSchema),
});

export function conversationSharedWithFromJSON(
  jsonString: string,
): SafeParseResult<ConversationSharedWith, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConversationSharedWith$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConversationSharedWith' from JSON`,
  );
}

/** @internal */
export const Conversation$inboundSchema: z.ZodMiniType<Conversation, unknown> =
  z.pipe(
    z.object({
      _id: types.optional(types.string()),
      userId: types.optional(types.string()),
      orgId: types.optional(types.string()),
      title: types.optional(types.string()),
      initiator: types.optional(types.string()),
      messages: types.optional(z.array(Message$inboundSchema)),
      status: types.optional(ConversationStatus$inboundSchema),
      failReason: types.optional(types.string()),
      modelInfo: types.optional(z.lazy(() => ModelInfo$inboundSchema)),
      isShared: z._default(types.boolean(), false),
      shareLink: types.optional(types.string()),
      sharedWith: types.optional(
        z.array(z.lazy(() => ConversationSharedWith$inboundSchema)),
      ),
      isArchived: z._default(types.boolean(), false),
      archivedBy: types.optional(types.string()),
      lastActivityAt: types.optional(types.number()),
      createdAt: types.optional(types.date()),
      updatedAt: types.optional(types.date()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "_id": "id",
      });
    }),
  );

export function conversationFromJSON(
  jsonString: string,
): SafeParseResult<Conversation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Conversation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Conversation' from JSON`,
  );
}
