/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";
import {
  SearchResultItem,
  SearchResultItem$inboundSchema,
} from "./search-result-item.js";

export const SearchResultAccessLevel = {
  Read: "read",
  Write: "write",
} as const;
export type SearchResultAccessLevel = OpenEnum<typeof SearchResultAccessLevel>;

export type SearchResultSharedWith = {
  userId?: string | undefined;
  accessLevel?: SearchResultAccessLevel | undefined;
};

/**
 * Result of a semantic search operation, containing matching
 *
 * @remarks
 * document chunks with relevance scores.
 */
export type SearchResult = {
  /**
   * Unique search record identifier
   */
  id?: string | undefined;
  /**
   * Alias for _id
   */
  searchId?: string | undefined;
  /**
   * The original search query
   */
  query?: string | undefined;
  /**
   * Matching content chunks
   */
  results?: Array<SearchResultItem> | undefined;
  /**
   * Map of record IDs to record names
   */
  records?: { [k: string]: string } | undefined;
  userId?: string | undefined;
  orgId?: string | undefined;
  isShared: boolean;
  sharedWith?: Array<SearchResultSharedWith> | undefined;
  isArchived: boolean;
  createdAt?: Date | undefined;
};

/** @internal */
export const SearchResultAccessLevel$inboundSchema: z.ZodMiniType<
  SearchResultAccessLevel,
  unknown
> = openEnums.inboundSchema(SearchResultAccessLevel);

/** @internal */
export const SearchResultSharedWith$inboundSchema: z.ZodMiniType<
  SearchResultSharedWith,
  unknown
> = z.object({
  userId: types.optional(types.string()),
  accessLevel: types.optional(SearchResultAccessLevel$inboundSchema),
});

export function searchResultSharedWithFromJSON(
  jsonString: string,
): SafeParseResult<SearchResultSharedWith, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchResultSharedWith$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchResultSharedWith' from JSON`,
  );
}

/** @internal */
export const SearchResult$inboundSchema: z.ZodMiniType<SearchResult, unknown> =
  z.pipe(
    z.object({
      _id: types.optional(types.string()),
      searchId: types.optional(types.string()),
      query: types.optional(types.string()),
      results: types.optional(z.array(SearchResultItem$inboundSchema)),
      records: types.optional(z.record(z.string(), types.string())),
      userId: types.optional(types.string()),
      orgId: types.optional(types.string()),
      isShared: z._default(types.boolean(), false),
      sharedWith: types.optional(
        z.array(z.lazy(() => SearchResultSharedWith$inboundSchema)),
      ),
      isArchived: z._default(types.boolean(), false),
      createdAt: types.optional(types.date()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "_id": "id",
      });
    }),
  );

export function searchResultFromJSON(
  jsonString: string,
): SafeParseResult<SearchResult, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchResult$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchResult' from JSON`,
  );
}
