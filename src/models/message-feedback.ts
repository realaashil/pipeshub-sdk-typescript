/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

export type Ratings = {
  /**
   * How accurate was the information (1-5)
   */
  accuracy?: number | undefined;
  /**
   * How relevant was the response (1-5)
   */
  relevance?: number | undefined;
  /**
   * How complete was the answer (1-5)
   */
  completeness?: number | undefined;
  /**
   * How clear was the explanation (1-5)
   */
  clarity?: number | undefined;
};

export const Category = {
  IncorrectInformation: "incorrect_information",
  MissingInformation: "missing_information",
  OutdatedInformation: "outdated_information",
  IrrelevantResponse: "irrelevant_response",
  TooVerbose: "too_verbose",
  TooBrief: "too_brief",
  FormattingIssues: "formatting_issues",
  CitationIssues: "citation_issues",
} as const;
export type Category = OpenEnum<typeof Category>;

export type Comments = {
  /**
   * What was good about the response
   */
  positive?: string | undefined;
  /**
   * What could be improved
   */
  negative?: string | undefined;
  /**
   * Specific suggestions for improvement
   */
  suggestions?: string | undefined;
};

export type CitationFeedback = {
  citationId?: string | undefined;
  isRelevant?: boolean | undefined;
  relevanceScore?: number | undefined;
  comment?: string | undefined;
};

/**
 * Comprehensive feedback on an AI response. Feedback helps improve
 *
 * @remarks
 * the AI's performance and response quality over time.
 */
export type MessageFeedback = {
  /**
   * Overall helpfulness rating
   */
  isHelpful?: boolean | undefined;
  ratings?: Ratings | undefined;
  /**
   * Categories of issues identified
   */
  categories?: Array<Category> | undefined;
  comments?: Comments | undefined;
  /**
   * Feedback on individual citations
   */
  citationFeedback?: Array<CitationFeedback> | undefined;
  /**
   * Were the suggested follow-up questions helpful
   */
  followUpQuestionsHelpful?: boolean | undefined;
};

/** @internal */
export const Ratings$inboundSchema: z.ZodMiniType<Ratings, unknown> = z.object({
  accuracy: types.optional(types.number()),
  relevance: types.optional(types.number()),
  completeness: types.optional(types.number()),
  clarity: types.optional(types.number()),
});
/** @internal */
export type Ratings$Outbound = {
  accuracy?: number | undefined;
  relevance?: number | undefined;
  completeness?: number | undefined;
  clarity?: number | undefined;
};

/** @internal */
export const Ratings$outboundSchema: z.ZodMiniType<Ratings$Outbound, Ratings> =
  z.object({
    accuracy: z.optional(z.int()),
    relevance: z.optional(z.int()),
    completeness: z.optional(z.int()),
    clarity: z.optional(z.int()),
  });

export function ratingsToJSON(ratings: Ratings): string {
  return JSON.stringify(Ratings$outboundSchema.parse(ratings));
}
export function ratingsFromJSON(
  jsonString: string,
): SafeParseResult<Ratings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Ratings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Ratings' from JSON`,
  );
}

/** @internal */
export const Category$inboundSchema: z.ZodMiniType<Category, unknown> =
  openEnums.inboundSchema(Category);
/** @internal */
export const Category$outboundSchema: z.ZodMiniType<string, Category> =
  openEnums.outboundSchema(Category);

/** @internal */
export const Comments$inboundSchema: z.ZodMiniType<Comments, unknown> = z
  .object({
    positive: types.optional(types.string()),
    negative: types.optional(types.string()),
    suggestions: types.optional(types.string()),
  });
/** @internal */
export type Comments$Outbound = {
  positive?: string | undefined;
  negative?: string | undefined;
  suggestions?: string | undefined;
};

/** @internal */
export const Comments$outboundSchema: z.ZodMiniType<
  Comments$Outbound,
  Comments
> = z.object({
  positive: z.optional(z.string()),
  negative: z.optional(z.string()),
  suggestions: z.optional(z.string()),
});

export function commentsToJSON(comments: Comments): string {
  return JSON.stringify(Comments$outboundSchema.parse(comments));
}
export function commentsFromJSON(
  jsonString: string,
): SafeParseResult<Comments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Comments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Comments' from JSON`,
  );
}

/** @internal */
export const CitationFeedback$inboundSchema: z.ZodMiniType<
  CitationFeedback,
  unknown
> = z.object({
  citationId: types.optional(types.string()),
  isRelevant: types.optional(types.boolean()),
  relevanceScore: types.optional(types.number()),
  comment: types.optional(types.string()),
});
/** @internal */
export type CitationFeedback$Outbound = {
  citationId?: string | undefined;
  isRelevant?: boolean | undefined;
  relevanceScore?: number | undefined;
  comment?: string | undefined;
};

/** @internal */
export const CitationFeedback$outboundSchema: z.ZodMiniType<
  CitationFeedback$Outbound,
  CitationFeedback
> = z.object({
  citationId: z.optional(z.string()),
  isRelevant: z.optional(z.boolean()),
  relevanceScore: z.optional(z.int()),
  comment: z.optional(z.string()),
});

export function citationFeedbackToJSON(
  citationFeedback: CitationFeedback,
): string {
  return JSON.stringify(
    CitationFeedback$outboundSchema.parse(citationFeedback),
  );
}
export function citationFeedbackFromJSON(
  jsonString: string,
): SafeParseResult<CitationFeedback, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CitationFeedback$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CitationFeedback' from JSON`,
  );
}

/** @internal */
export const MessageFeedback$inboundSchema: z.ZodMiniType<
  MessageFeedback,
  unknown
> = z.object({
  isHelpful: types.optional(types.boolean()),
  ratings: types.optional(z.lazy(() => Ratings$inboundSchema)),
  categories: types.optional(z.array(Category$inboundSchema)),
  comments: types.optional(z.lazy(() => Comments$inboundSchema)),
  citationFeedback: types.optional(
    z.array(z.lazy(() => CitationFeedback$inboundSchema)),
  ),
  followUpQuestionsHelpful: types.optional(types.boolean()),
});
/** @internal */
export type MessageFeedback$Outbound = {
  isHelpful?: boolean | undefined;
  ratings?: Ratings$Outbound | undefined;
  categories?: Array<string> | undefined;
  comments?: Comments$Outbound | undefined;
  citationFeedback?: Array<CitationFeedback$Outbound> | undefined;
  followUpQuestionsHelpful?: boolean | undefined;
};

/** @internal */
export const MessageFeedback$outboundSchema: z.ZodMiniType<
  MessageFeedback$Outbound,
  MessageFeedback
> = z.object({
  isHelpful: z.optional(z.boolean()),
  ratings: z.optional(z.lazy(() => Ratings$outboundSchema)),
  categories: z.optional(z.array(Category$outboundSchema)),
  comments: z.optional(z.lazy(() => Comments$outboundSchema)),
  citationFeedback: z.optional(
    z.array(z.lazy(() => CitationFeedback$outboundSchema)),
  ),
  followUpQuestionsHelpful: z.optional(z.boolean()),
});

export function messageFeedbackToJSON(
  messageFeedback: MessageFeedback,
): string {
  return JSON.stringify(MessageFeedback$outboundSchema.parse(messageFeedback));
}
export function messageFeedbackFromJSON(
  jsonString: string,
): SafeParseResult<MessageFeedback, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageFeedback$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageFeedback' from JSON`,
  );
}
