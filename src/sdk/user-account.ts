/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { userAccountAuthenticate } from "../funcs/user-account-authenticate.js";
import { userAccountCheckPasswordStatus } from "../funcs/user-account-check-password-status.js";
import { userAccountForgotPassword } from "../funcs/user-account-forgot-password.js";
import { userAccountGenerateLoginOtp } from "../funcs/user-account-generate-login-otp.js";
import { userAccountInitializeAuth } from "../funcs/user-account-initialize-auth.js";
import { userAccountLogout } from "../funcs/user-account-logout.js";
import { userAccountRefresh } from "../funcs/user-account-refresh.js";
import { userAccountResetPasswordWithToken } from "../funcs/user-account-reset-password-with-token.js";
import { userAccountResetPassword } from "../funcs/user-account-reset-password.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as models from "../models/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class UserAccount extends ClientSDK {
  /**
   * Initialize authentication session
   *
   * @remarks
   * Initialize an authentication session for a user by email address.
   * This is the first step in the multi-step authentication flow.
   * <br><br>
   * <b>Flow:</b><br>
   * 1. Call this endpoint with the user's email<br>
   * 2. Receive a session token in the <code>x-session-token</code> response header<br>
   * 3. Use the session token in subsequent <code>/authenticate</code> calls<br>
   * 4. The response includes <code>allowedMethods</code> for the first authentication step
   * <br><br>
   * <b>Session Token:</b><br>
   * - Stored in response header <code>x-session-token</code><br>
   * - Required for all subsequent authentication requests<br>
   * - Expires after a configured timeout period
   * <br><br>
   * <b>Multi-Factor Authentication:</b><br>
   * If the organization has MFA configured, you'll need to complete multiple
   * authentication steps. Each step completion returns the next step's allowed methods.
   */
  async initializeAuth(
    request: models.InitAuthRequest,
    options?: RequestOptions,
  ): Promise<operations.InitAuthResponse> {
    return unwrapAsync(userAccountInitializeAuth(
      this,
      request,
      options,
    ));
  }

  /**
   * Authenticate user with credentials
   *
   * @remarks
   * Authenticate a user using the specified method and credentials.
   * Requires a valid session token from <code>/initAuth</code>.
   * <br><br>
   * <b>Credential Formats by Method:</b><br>
   * - <code>password</code>: <code>{ "credentials": { "password": "your-password" } }</code><br>
   * - <code>otp</code>: <code>{ "credentials": { "otp": "123456" } }</code> (6-digit code, valid for 10 minutes)<br>
   * - <code>google</code>: <code>{ "credentials": "google-id-token-string" }</code><br>
   * - <code>microsoft</code>: <code>{ "credentials": { "accessToken": "...", "idToken": "..." } }</code><br>
   * - <code>azureAd</code>: <code>{ "credentials": { "accessToken": "...", "idToken": "..." } }</code><br>
   * - <code>oauth</code>: <code>{ "credentials": { "accessToken": "...", "idToken": "..." } }</code><br>
   * - <code>samlSso</code>: Handled via redirect flow (use <code>/saml/signIn</code> instead)
   * <br><br>
   * <b>Multi-Step Response:</b><br>
   * If organization uses MFA, successful authentication returns:<br>
   * - <code>status: "success"</code> with <code>nextStep</code> and <code>allowedMethods</code> for next step
   * <br><br>
   * <b>Fully Authenticated Response:</b><br>
   * After completing all steps:<br>
   * - <code>message: "Fully authenticated"</code> with <code>accessToken</code> (1hr) and <code>refreshToken</code> (7d)
   * <br><br>
   * <b>Security:</b><br>
   * - Account locks after 5 consecutive failed attempts<br>
   * - CAPTCHA may be required if enabled (pass <code>cf-turnstile-response</code>)
   */
  async authenticate(
    request: operations.AuthenticateRequest,
    options?: RequestOptions,
  ): Promise<models.AuthenticateResponse> {
    return unwrapAsync(userAccountAuthenticate(
      this,
      request,
      options,
    ));
  }

  /**
   * Generate and send OTP for login
   *
   * @remarks
   * Generate and send a 6-digit one-time password (OTP) to the user's email.
   * Use this endpoint before authenticating with the <code>otp</code> method.
   * <br><br>
   * <b>OTP Details:</b><br>
   * - 6 digits numeric code<br>
   * - Valid for <b>10 minutes</b> after generation<br>
   * - Sent to user's registered email address
   * <br><br>
   * <b>Rate Limiting:</b><br>
   * - Multiple OTP requests may be rate-limited<br>
   * - Wait for the current OTP to expire before requesting a new one
   * <br><br>
   * <b>CAPTCHA:</b><br>
   * If Cloudflare Turnstile is enabled, include <code>cf-turnstile-response</code> in the request body.
   */
  async generateLoginOtp(
    request: models.OtpGenerateRequest,
    options?: RequestOptions,
  ): Promise<operations.GenerateLoginOtpResponse> {
    return unwrapAsync(userAccountGenerateLoginOtp(
      this,
      request,
      options,
    ));
  }

  /**
   * Reset password (authenticated user)
   *
   * @remarks
   * Reset password for an authenticated user. Requires the current password for verification.
   * <br><br>
   * <b>Password Requirements:</b><br>
   * - Minimum 8 characters<br>
   * - At least 1 uppercase letter (A-Z)<br>
   * - At least 1 lowercase letter (a-z)<br>
   * - At least 1 number (0-9)<br>
   * - At least 1 special character (#?!@$%^&*-)
   * <br><br>
   * <b>Security Notes:</b><br>
   * - A new access token is returned (old tokens are invalidated)<br>
   * - CAPTCHA may be required if enabled (pass <code>cf-turnstile-response</code>)
   */
  async resetPassword(
    request: models.PasswordResetRequest,
    options?: RequestOptions,
  ): Promise<models.PasswordResetResponse> {
    return unwrapAsync(userAccountResetPassword(
      this,
      request,
      options,
    ));
  }

  /**
   * Request password reset email
   *
   * @remarks
   * Send a password reset link to the user's email.
   * The link contains a time-limited token that can be used to reset the password.
   * <br><br>
   * <b>Note:</b> This endpoint always returns 200 even if the email doesn't exist (to prevent email enumeration).
   */
  async forgotPassword(
    request: models.ForgotPasswordRequest,
    options?: RequestOptions,
  ): Promise<operations.ForgotPasswordResponse> {
    return unwrapAsync(userAccountForgotPassword(
      this,
      request,
      options,
    ));
  }

  /**
   * Reset password with email token
   *
   * @remarks
   * Reset password using a token received via email from the forgot password flow.
   * <br><br>
   * <b>Password Requirements:</b><br>
   * - Minimum 8 characters<br>
   * - At least 1 uppercase letter<br>
   * - At least 1 lowercase letter<br>
   * - At least 1 number<br>
   * - At least 1 special character (#?!@$%^&*-)
   * <br><br>
   * <b>Security Notes:</b><br>
   * - Token is single-use and expires after a set time<br>
   * - A new access token is returned upon successful reset
   */
  async resetPasswordWithToken(
    security: operations.ResetPasswordWithTokenSecurity,
    request: models.TokenPasswordResetRequest,
    options?: RequestOptions,
  ): Promise<models.PasswordResetResponse> {
    return unwrapAsync(userAccountResetPasswordWithToken(
      this,
      security,
      request,
      options,
    ));
  }

  /**
   * Check if user has password set (Internal)
   *
   * @remarks
   * Internal endpoint to check if a user has a password configured.
   * Used by other services to determine authentication capabilities.
   * <br><br>
   * <b>Note:</b> This is an internal service-to-service endpoint.
   */
  async checkPasswordStatus(
    security: operations.CheckPasswordStatusSecurity,
    options?: RequestOptions,
  ): Promise<operations.CheckPasswordStatusResponse> {
    return unwrapAsync(userAccountCheckPasswordStatus(
      this,
      security,
      options,
    ));
  }

  /**
   * Refresh access token
   *
   * @remarks
   * Get a new access token using a valid refresh token.
   * <br><br>
   * <b>Usage:</b><br>
   * - Pass the refresh token as a Bearer token in the Authorization header<br>
   * - Returns a new access token (1 hour expiry) and basic user information
   * <br><br>
   * <b>Token Lifetimes:</b><br>
   * - Access token: 1 hour<br>
   * - Refresh token: 7 days
   * <br><br>
   * <b>Best Practices:</b><br>
   * - Call this endpoint before the access token expires<br>
   * - Store the new access token and continue using it for authenticated requests<br>
   * - If refresh fails with 401, redirect user to login flow
   */
  async refresh(
    security: operations.RefreshTokenSecurity,
    options?: RequestOptions,
  ): Promise<models.RefreshTokenResponse> {
    return unwrapAsync(userAccountRefresh(
      this,
      security,
      options,
    ));
  }

  /**
   * Logout current session
   *
   * @remarks
   * Log out the current user session and invalidate tokens.
   * <br><br>
   * <b>Effects:</b><br>
   * - Invalidates the current access token<br>
   * - Clears server-side session data<br>
   * - Client should also clear stored tokens locally
   * <br><br>
   * <b>Note:</b> This endpoint requires the access token, not the refresh token.
   */
  async logout(
    options?: RequestOptions,
  ): Promise<operations.LogoutResponse> {
    return unwrapAsync(userAccountLogout(
      this,
      options,
    ));
  }
}
