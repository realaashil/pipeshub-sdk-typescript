/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { semanticSearchArchive } from "../funcs/semantic-search-archive.js";
import { semanticSearchDeleteAllHistory } from "../funcs/semantic-search-delete-all-history.js";
import { semanticSearchDelete } from "../funcs/semantic-search-delete.js";
import { semanticSearchGetById } from "../funcs/semantic-search-get-by-id.js";
import { semanticSearchGetHistory } from "../funcs/semantic-search-get-history.js";
import { semanticSearchPatchShare } from "../funcs/semantic-search-patch-share.js";
import { semanticSearchPostSearch } from "../funcs/semantic-search-post-search.js";
import { semanticSearchUnarchive } from "../funcs/semantic-search-unarchive.js";
import { semanticSearchUnshare } from "../funcs/semantic-search-unshare.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as models from "../models/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class SemanticSearch extends ClientSDK {
  /**
   * Perform semantic search
   *
   * @remarks
   * Execute a semantic search across your organization's knowledge base.<br><br>
   * <b>Overview:</b><br>
   * Semantic search uses AI embeddings to find content based on meaning,
   * not just keyword matching. This enables finding relevant information
   * even when the exact words differ.<br><br>
   * <b>How It Works:</b><br>
   * <ol>
   * <li>Your query is converted to a vector embedding</li>
   * <li>The system finds documents with similar semantic meaning</li>
   * <li>Results are ranked by relevance score</li>
   * <li>Matching chunks are returned with metadata</li>
   * </ol>
   * <b>Filtering:</b><br>
   * Use filters to narrow your search:
   * <ul>
   * <li><code>filters.apps</code>: Limit to specific connector apps (Google Drive, Confluence, etc.)</li>
   * <li><code>filters.kb</code>: Limit to specific knowledge bases</li>
   * </ul>
   * <b>Results:</b><br>
   * Each result includes:
   * <ul>
   * <li>Matching content chunk</li>
   * <li>Relevance score (0-1, higher is better)</li>
   * <li>Source document metadata (name, URL, type)</li>
   * </ul>
   * <b>Search History:</b><br>
   * All searches are saved and can be retrieved via <code>GET /search</code>.
   */
  async postSearch(
    request: models.SemanticSearchRequest,
    options?: RequestOptions,
  ): Promise<models.SearchResult> {
    return unwrapAsync(semanticSearchPostSearch(
      this,
      request,
      options,
    ));
  }

  /**
   * Get search history
   *
   * @remarks
   * Retrieve your search history with pagination.<br><br>
   * <b>Overview:</b><br>
   * Returns a list of all searches performed by the authenticated user.
   * Each entry includes the original query, results, and metadata.<br><br>
   * <b>Pagination:</b><br>
   * Use <code>page</code> and <code>limit</code> to navigate through results.
   */
  async getHistory(
    request?: operations.SearchHistoryRequest | undefined,
    options?: RequestOptions,
  ): Promise<operations.SearchHistoryResponse> {
    return unwrapAsync(semanticSearchGetHistory(
      this,
      request,
      options,
    ));
  }

  /**
   * Clear all search history
   *
   * @remarks
   * Delete all search history for the authenticated user.<br><br>
   * <b>Warning:</b><br>
   * This action cannot be undone. All saved searches will be permanently removed.
   */
  async deleteAllHistory(
    options?: RequestOptions,
  ): Promise<operations.DeleteAllSearchHistoryResponse> {
    return unwrapAsync(semanticSearchDeleteAllHistory(
      this,
      options,
    ));
  }

  /**
   * Get search by ID
   *
   * @remarks
   * Retrieve a specific search result by its ID.<br><br>
   * <b>Overview:</b><br>
   * Returns the full search record including query, all results,
   * and any sharing/archive status.
   */
  async getById(
    request: operations.GetSearchByIdRequest,
    options?: RequestOptions,
  ): Promise<models.SearchResult> {
    return unwrapAsync(semanticSearchGetById(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete search
   *
   * @remarks
   * Delete a specific search from history.<br><br>
   * <b>Overview:</b><br>
   * Permanently removes the search record from your history.
   */
  async delete(
    request: operations.DeleteSearchRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(semanticSearchDelete(
      this,
      request,
      options,
    ));
  }

  /**
   * Share search results
   *
   * @remarks
   * Share search results with other users.<br><br>
   * <b>Overview:</b><br>
   * Allows sharing a search and its results with colleagues.
   * Useful for collaborative research or knowledge sharing.
   */
  async patchShare(
    request: operations.ShareSearchRequest,
    options?: RequestOptions,
  ): Promise<models.SearchResult> {
    return unwrapAsync(semanticSearchPatchShare(
      this,
      request,
      options,
    ));
  }

  /**
   * Revoke search access
   *
   * @remarks
   * Remove sharing access from specified users.
   */
  async unshare(
    request: operations.UnshareSearchRequest,
    options?: RequestOptions,
  ): Promise<models.SearchResult> {
    return unwrapAsync(semanticSearchUnshare(
      this,
      request,
      options,
    ));
  }

  /**
   * Archive search
   *
   * @remarks
   * Archive a search to hide it from the main history list.
   */
  async archive(
    request: operations.ArchiveSearchRequest,
    options?: RequestOptions,
  ): Promise<models.SearchResult> {
    return unwrapAsync(semanticSearchArchive(
      this,
      request,
      options,
    ));
  }

  /**
   * Unarchive search
   *
   * @remarks
   * Restore an archived search to the active history list.
   */
  async unarchive(
    request: operations.UnarchiveSearchRequest,
    options?: RequestOptions,
  ): Promise<models.SearchResult> {
    return unwrapAsync(semanticSearchUnarchive(
      this,
      request,
      options,
    ));
  }
}
