/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { documentManagementDelete } from "../funcs/document-management-delete.js";
import { documentManagementDownload } from "../funcs/document-management-download.js";
import { documentManagementGetById } from "../funcs/document-management-get-by-id.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class DocumentManagement extends ClientSDK {
  /**
   * Get document by ID
   *
   * @remarks
   * Retrieve complete document metadata by its unique identifier.<br><br>
   * <b>Overview:</b><br>
   * Returns all document information including metadata, version history, storage location, and access permissions. Use this to display document details or prepare for download/edit operations.<br><br>
   * <b>Response Includes:</b><br>
   * <ul>
   * <li>Document metadata (name, path, size, type)</li>
   * <li>Storage information (vendor, URLs)</li>
   * <li>Version history (if versioned)</li>
   * <li>Permission settings</li>
   * <li>Custom metadata</li>
   * <li>Timestamps (created, updated)</li>
   * </ul>
   * <b>Authorization:</b><br>
   * Document must belong to the requesting user's organization.<br><br>
   * <b>Note:</b> Soft-deleted documents (isDeleted: true) are not returned.
   */
  async getById(
    request: operations.GetDocumentByIdRequest,
    options?: RequestOptions,
  ): Promise<operations.GetDocumentByIdResponse> {
    return unwrapAsync(documentManagementGetById(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete document
   *
   * @remarks
   * Soft delete a document from the system. The document is marked as deleted but not permanently removed.<br><br>
   * <b>Overview:</b><br>
   * This endpoint performs a soft delete, marking the document as deleted while preserving its data for potential recovery or audit purposes.<br><br>
   * <b>What Happens on Delete:</b><br>
   * <ul>
   * <li><code>isDeleted</code> flag set to true</li>
   * <li><code>deletedByUserId</code> recorded</li>
   * <li>Document excluded from normal queries</li>
   * <li>File remains in storage (soft delete)</li>
   * </ul>
   * <b>Restrictions:</b><br>
   * <ul>
   * <li>Document must belong to user's organization</li>
   * <li>User must have appropriate permissions</li>
   * </ul>
   * <b>Recovery:</b><br>
   * Soft-deleted documents can be restored by administrators if needed.
   */
  async delete(
    request: operations.DeleteDocumentByIdRequest,
    options?: RequestOptions,
  ): Promise<operations.DeleteDocumentByIdResponse> {
    return unwrapAsync(documentManagementDelete(
      this,
      request,
      options,
    ));
  }

  /**
   * Download document
   *
   * @remarks
   * Get a time-limited signed URL to download the document, or receive the file directly for local storage.<br><br>
   * <b>Overview:</b><br>
   * This endpoint generates secure download access to documents. For cloud storage (S3/Azure), it returns a presigned URL. For local storage, it streams the file directly.<br><br>
   * <b>Download Behavior by Storage:</b><br>
   * <ul>
   * <li><b>S3/Azure:</b> Returns presigned URL valid for specified duration</li>
   * <li><b>Local:</b> Streams file directly with appropriate headers</li>
   * </ul>
   * <b>Version Download:</b><br>
   * Specify the <code>version</code> parameter to download a specific historical version. Only available for versioned documents.<br><br>
   * <b>URL Expiration:</b><br>
   * <ul>
   * <li>Default: 3600 seconds (1 hour)</li>
   * <li>Configurable via <code>expirationTimeInSeconds</code></li>
   * <li>Maximum depends on storage provider limits</li>
   * </ul>
   * <b>Security:</b><br>
   * Signed URLs are single-use and time-limited. They can be safely shared for temporary access.
   */
  async download(
    request: operations.DownloadDocumentRequest,
    options?: RequestOptions,
  ): Promise<operations.DownloadDocumentResponse> {
    return unwrapAsync(documentManagementDownload(
      this,
      request,
      options,
    ));
  }
}
