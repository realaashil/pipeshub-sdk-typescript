/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { conversationsAddMessageStream } from "../funcs/conversations-add-message-stream.js";
import { conversationsAddMessage } from "../funcs/conversations-add-message.js";
import { conversationsCreate } from "../funcs/conversations-create.js";
import { conversationsDelete } from "../funcs/conversations-delete.js";
import { conversationsGet } from "../funcs/conversations-get.js";
import { conversationsListArchived } from "../funcs/conversations-list-archived.js";
import { conversationsList } from "../funcs/conversations-list.js";
import { conversationsPatchArchive } from "../funcs/conversations-patch-archive.js";
import { conversationsRegenerateAnswer } from "../funcs/conversations-regenerate-answer.js";
import { conversationsShare } from "../funcs/conversations-share.js";
import { conversationsStream } from "../funcs/conversations-stream.js";
import { conversationsUnarchive } from "../funcs/conversations-unarchive.js";
import { conversationsUnshare } from "../funcs/conversations-unshare.js";
import { conversationsUpdateMessageFeedback } from "../funcs/conversations-update-message-feedback.js";
import { conversationsUpdateTitle } from "../funcs/conversations-update-title.js";
import { EventStream } from "../lib/event-streams.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as models from "../models/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class Conversations extends ClientSDK {
  /**
   * Create a new AI conversation
   *
   * @remarks
   * Start a new conversation with PipesHub's AI assistant.<br><br>
   * <b>Overview:</b><br>
   * This endpoint creates a new conversation session and processes the initial query.
   * The AI searches your organization's knowledge bases for relevant information and
   * generates a response with citations to source documents.<br><br>
   * <b>How It Works:</b><br>
   * <ol>
   * <li>Your query is analyzed and converted to semantic embeddings</li>
   * <li>Relevant content is retrieved from indexed knowledge bases</li>
   * <li>The AI generates a response using the retrieved context</li>
   * <li>Citations link back to source documents for verification</li>
   * <li>Follow-up questions are suggested based on the conversation</li>
   * </ol>
   * <b>Filtering Options:</b><br>
   * <ul>
   * <li><b>recordIds:</b> Limit search to specific documents</li>
   * <li><b>filters.apps:</b> Search only specific connector apps</li>
   * <li><b>filters.kb:</b> Search only specific knowledge bases</li>
   * </ul>
   * <b>Model Selection:</b><br>
   * Use <code>modelKey</code> to select different AI models configured for your organization.
   * Each model may have different capabilities, speed, and accuracy trade-offs.
   */
  async create(
    request: models.CreateConversationRequest,
    options?: RequestOptions,
  ): Promise<models.Conversation> {
    return unwrapAsync(conversationsCreate(
      this,
      request,
      options,
    ));
  }

  /**
   * Create conversation with streaming response
   *
   * @remarks
   * Start a new conversation with real-time streaming response using Server-Sent Events (SSE).<br><br>
   * <b>Overview:</b><br>
   * This endpoint works like <code>/conversations/create</code> but streams the AI response
   * in real-time as it's generated, providing a more interactive user experience.<br><br>
   * <b>SSE Event Types:</b><br>
   * <ul>
   * <li><code>connected</code> - Connection established, processing started</li>
   * <li><code>chunk</code> - Partial response text (stream these to show typing effect)</li>
   * <li><code>citation</code> - Citation reference found during generation</li>
   * <li><code>complete</code> - Final message with full response, citations, and follow-up questions</li>
   * <li><code>error</code> - Error occurred during processing</li>
   * </ul>
   * <b>Client Implementation:</b><br>
   * <code>
   * const eventSource = new EventSource('/conversations/stream');<br>
   * eventSource.onmessage = (event) => {<br>
   * &nbsp;&nbsp;const data = JSON.parse(event.data);<br>
   * &nbsp;&nbsp;// Handle different event types<br>
   * };
   * </code><br><br>
   * <b>Error Handling:</b><br>
   * If an error occurs mid-stream, an <code>error</code> event is sent and the stream closes.
   * The conversation is marked as FAILED with the error reason stored.
   */
  async stream(
    request: models.CreateConversationRequest,
    options?: RequestOptions,
  ): Promise<EventStream<models.SSEEvent>> {
    return unwrapAsync(conversationsStream(
      this,
      request,
      options,
    ));
  }

  /**
   * List all conversations
   *
   * @remarks
   * Retrieve all conversations for the authenticated user.<br><br>
   * <b>Overview:</b><br>
   * Returns a list of all conversations owned by or shared with the current user.
   * Conversations are returned with their messages, status, and metadata.<br><br>
   * <b>Filtering:</b><br>
   * <ul>
   * <li>Only non-archived conversations are returned by default</li>
   * <li>Use <code>/conversations/show/archives</code> for archived conversations</li>
   * </ul>
   * <b>Sorting:</b><br>
   * Conversations are sorted by last activity timestamp (most recent first).
   */
  async list(
    options?: RequestOptions,
  ): Promise<Array<models.Conversation>> {
    return unwrapAsync(conversationsList(
      this,
      options,
    ));
  }

  /**
   * List archived conversations
   *
   * @remarks
   * Retrieve all archived conversations for the authenticated user.<br><br>
   * <b>Overview:</b><br>
   * Archived conversations are hidden from the main list but preserved for reference.
   * This endpoint returns only conversations where <code>isArchived: true</code>.<br><br>
   * <b>Unarchiving:</b><br>
   * Use <code>PATCH /conversations/{id}/unarchive</code> to restore a conversation
   * to the active list.
   */
  async listArchived(
    options?: RequestOptions,
  ): Promise<Array<models.Conversation>> {
    return unwrapAsync(conversationsListArchived(
      this,
      options,
    ));
  }

  /**
   * Get conversation by ID
   *
   * @remarks
   * Retrieve a specific conversation with its full message history.<br><br>
   * <b>Overview:</b><br>
   * Returns the complete conversation including all messages, citations,
   * feedback, and metadata. Messages can be paginated for long conversations.<br><br>
   * <b>Message Pagination:</b><br>
   * For conversations with many messages, use pagination parameters:
   * <ul>
   * <li><code>page</code>: Page number (default: 1)</li>
   * <li><code>limit</code>: Messages per page (default: 10)</li>
   * <li><code>sortBy</code>: Sort field (default: createdAt)</li>
   * <li><code>sortOrder</code>: 'asc' or 'desc' (default: desc)</li>
   * </ul>
   * <b>Access Control:</b><br>
   * Users can access conversations they own or that have been shared with them.
   */
  async get(
    request: operations.GetConversationByIdRequest,
    options?: RequestOptions,
  ): Promise<operations.GetConversationByIdResponse> {
    return unwrapAsync(conversationsGet(
      this,
      request,
      options,
    ));
  }

  /**
   * Delete conversation
   *
   * @remarks
   * Delete a conversation by its ID.<br><br>
   * <b>Overview:</b><br>
   * Performs a soft delete by setting <code>isDeleted: true</code>.
   * The conversation is removed from listings but preserved in the database.<br><br>
   * <b>Permissions:</b><br>
   * Only the conversation owner (initiator) can delete it.
   * Shared users cannot delete conversations.
   */
  async delete(
    request: operations.DeleteConversationByIdRequest,
    options?: RequestOptions,
  ): Promise<operations.DeleteConversationByIdResponse> {
    return unwrapAsync(conversationsDelete(
      this,
      request,
      options,
    ));
  }

  /**
   * Add message to conversation
   *
   * @remarks
   * Add a follow-up message to an existing conversation.<br><br>
   * <b>Overview:</b><br>
   * Continues an existing conversation by adding a new user query.
   * The AI maintains context from previous messages when generating the response.<br><br>
   * <b>Context Handling:</b><br>
   * <ul>
   * <li>Previous messages provide context for the new query</li>
   * <li>Citations from earlier messages may be referenced</li>
   * <li>The AI can refer back to previous topics discussed</li>
   * </ul>
   * <b>Model Override:</b><br>
   * You can specify a different model for this message using <code>modelKey</code>.
   * This allows switching models mid-conversation if needed.
   */
  async addMessage(
    request: operations.AddMessageRequest,
    options?: RequestOptions,
  ): Promise<models.Conversation> {
    return unwrapAsync(conversationsAddMessage(
      this,
      request,
      options,
    ));
  }

  /**
   * Add message with streaming response
   *
   * @remarks
   * Add a follow-up message to an existing conversation with real-time SSE streaming.<br><br>
   * <b>Overview:</b><br>
   * Same as <code>POST /conversations/{id}/messages</code> but with streaming response.
   * Provides real-time feedback as the AI generates its response.<br><br>
   * <b>SSE Events:</b><br>
   * See <code>/conversations/stream</code> for event type documentation.
   */
  async addMessageStream(
    request: operations.AddMessageStreamRequest,
    options?: RequestOptions,
  ): Promise<EventStream<models.SSEEvent>> {
    return unwrapAsync(conversationsAddMessageStream(
      this,
      request,
      options,
    ));
  }

  /**
   * Share conversation with users
   *
   * @remarks
   * Share a conversation with other users in your organization.<br><br>
   * <b>Overview:</b><br>
   * Allows the conversation owner to grant access to other users.
   * Shared users can view the conversation and optionally add messages.<br><br>
   * <b>Access Levels:</b><br>
   * <ul>
   * <li><code>read</code> - Can view conversation and messages (default)</li>
   * <li><code>write</code> - Can view and add new messages</li>
   * </ul>
   * <b>Permissions:</b><br>
   * Only the conversation initiator (owner) can share. Users must belong
   * to the same organization.
   */
  async share(
    request: operations.ShareConversationRequest,
    options?: RequestOptions,
  ): Promise<models.Conversation> {
    return unwrapAsync(conversationsShare(
      this,
      request,
      options,
    ));
  }

  /**
   * Revoke conversation access
   *
   * @remarks
   * Remove sharing access from users.<br><br>
   * <b>Overview:</b><br>
   * Removes specified users from the conversation's sharedWith list.
   * Those users will no longer be able to access the conversation.<br><br>
   * <b>Permissions:</b><br>
   * Only the conversation owner can revoke access.
   */
  async unshare(
    request: operations.UnshareConversationRequest,
    options?: RequestOptions,
  ): Promise<models.Conversation> {
    return unwrapAsync(conversationsUnshare(
      this,
      request,
      options,
    ));
  }

  /**
   * Update conversation title
   *
   * @remarks
   * Update the title of a conversation.<br><br>
   * <b>Overview:</b><br>
   * Conversation titles are auto-generated from the first query by default.
   * Use this endpoint to set a custom, more descriptive title.<br><br>
   * <b>Title Limits:</b><br>
   * <ul>
   * <li>Minimum: 1 character</li>
   * <li>Maximum: 200 characters</li>
   * </ul>
   */
  async updateTitle(
    request: operations.UpdateConversationTitleRequest,
    options?: RequestOptions,
  ): Promise<models.Conversation> {
    return unwrapAsync(conversationsUpdateTitle(
      this,
      request,
      options,
    ));
  }

  /**
   * Archive conversation
   *
   * @remarks
   * Archive a conversation to hide it from the main list.<br><br>
   * <b>Overview:</b><br>
   * Archived conversations are preserved but hidden from the default conversation list.
   * Use archiving to clean up your workspace without permanently deleting conversations.<br><br>
   * <b>Retrieval:</b><br>
   * View archived conversations using <code>GET /conversations/show/archives</code>.
   */
  async patchArchive(
    request: operations.ArchiveConversationRequest,
    options?: RequestOptions,
  ): Promise<models.Conversation> {
    return unwrapAsync(conversationsPatchArchive(
      this,
      request,
      options,
    ));
  }

  /**
   * Unarchive conversation
   *
   * @remarks
   * Restore an archived conversation to the active list.<br><br>
   * <b>Overview:</b><br>
   * Removes the archived flag, making the conversation visible in the main list again.
   */
  async unarchive(
    request: operations.UnarchiveConversationRequest,
    options?: RequestOptions,
  ): Promise<models.Conversation> {
    return unwrapAsync(conversationsUnarchive(
      this,
      request,
      options,
    ));
  }

  /**
   * Regenerate AI response
   *
   * @remarks
   * Regenerate the AI response for a specific message.<br><br>
   * <b>Overview:</b><br>
   * If you're not satisfied with an AI response, use this endpoint to generate
   * a new answer. The AI will re-process the original query and may produce
   * a different response.<br><br>
   * <b>Use Cases:</b><br>
   * <ul>
   * <li>Response was incomplete or unclear</li>
   * <li>Want to try a different AI model</li>
   * <li>New documents have been indexed since original response</li>
   * </ul>
   * <b>Model Override:</b><br>
   * Specify <code>modelKey</code> to use a different model for regeneration.
   */
  async regenerateAnswer(
    request: operations.RegenerateAnswerRequest,
    options?: RequestOptions,
  ): Promise<models.Conversation> {
    return unwrapAsync(conversationsRegenerateAnswer(
      this,
      request,
      options,
    ));
  }

  /**
   * Submit feedback on AI response
   *
   * @remarks
   * Provide feedback on an AI-generated response.<br><br>
   * <b>Overview:</b><br>
   * Feedback helps improve AI response quality over time. You can rate
   * various aspects of the response and provide detailed comments.<br><br>
   * <b>Feedback Options:</b><br>
   * <ul>
   * <li><b>isHelpful:</b> Overall thumbs up/down</li>
   * <li><b>ratings:</b> 1-5 scale for accuracy, relevance, completeness, clarity</li>
   * <li><b>categories:</b> Issue categories (incorrect info, too verbose, etc.)</li>
   * <li><b>comments:</b> Free-text positive/negative feedback and suggestions</li>
   * <li><b>citationFeedback:</b> Rate individual citations</li>
   * </ul>
   * <b>Restrictions:</b><br>
   * Feedback can only be submitted on <code>bot_response</code> messages,
   * not on user queries or system messages.
   */
  async updateMessageFeedback(
    request: operations.UpdateMessageFeedbackRequest,
    options?: RequestOptions,
  ): Promise<models.Conversation> {
    return unwrapAsync(conversationsUpdateMessageFeedback(
      this,
      request,
      options,
    ));
  }
}
