/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { oauthProviderAuthorize } from "../funcs/oauth-provider-authorize.js";
import { oauthProviderExchange } from "../funcs/oauth-provider-exchange.js";
import { oauthProviderIntrospect } from "../funcs/oauth-provider-introspect.js";
import { oauthProviderRevokeToken } from "../funcs/oauth-provider-revoke-token.js";
import { oauthProviderSubmitConsent } from "../funcs/oauth-provider-submit-consent.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as models from "../models/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";

export class OauthProvider extends ClientSDK {
  /**
   * Initiate OAuth authorization flow
   *
   * @remarks
   * OAuth 2.0 Authorization Endpoint (RFC 6749 Section 4.1.1).
   * <br><br>
   * Initiates the authorization code flow. Users are redirected here by OAuth clients
   * to authorize access to their account.
   * <br><br>
   * <b>Flow:</b><br>
   * 1. Client redirects user to this endpoint with required parameters<br>
   * 2. If not logged in, user is redirected to PipesHub login<br>
   * 3. User sees consent page with requested scopes<br>
   * 4. User grants or denies consent<br>
   * 5. User is redirected back to client with authorization code
   * <br><br>
   * <b>PKCE Support (RFC 7636):</b><br>
   * - Required for public clients (SPA, mobile apps)<br>
   * - Recommended for confidential clients<br>
   * - Use S256 method (SHA256 hash of code_verifier)
   * <br><br>
   * <b>Security:</b><br>
   * - Always use HTTPS in production<br>
   * - State parameter provides CSRF protection<br>
   * - Redirect URI must match registered URIs exactly
   */
  async authorize(
    request: operations.OauthAuthorizeRequest,
    options?: RequestOptions,
  ): Promise<operations.OauthAuthorizeResponse | undefined> {
    return unwrapAsync(oauthProviderAuthorize(
      this,
      request,
      options,
    ));
  }

  /**
   * Submit authorization consent
   *
   * @remarks
   * Submit user's consent decision for OAuth authorization.
   * <br><br>
   * Called after user reviews the consent page and makes a decision.
   * This endpoint generates an authorization code if consent is granted.
   * <br><br>
   * <b>Responses:</b><br>
   * - Consent granted: Redirects to client with authorization code<br>
   * - Consent denied: Redirects to client with `access_denied` error
   */
  async submitConsent(
    request: models.OAuthConsentRequest,
    options?: RequestOptions,
  ): Promise<operations.OauthAuthorizeConsentResponse> {
    return unwrapAsync(oauthProviderSubmitConsent(
      this,
      request,
      options,
    ));
  }

  /**
   * Exchange authorization code for tokens
   *
   * @remarks
   * OAuth 2.0 Token Endpoint (RFC 6749 Section 4.1.3).
   * <br><br>
   * Exchanges an authorization code, client credentials, or refresh token for access tokens.
   * <br><br>
   * <b>Grant Types:</b><br>
   * - `authorization_code`: Exchange auth code for tokens (user-based)<br>
   * - `client_credentials`: Get tokens for machine-to-machine auth<br>
   * - `refresh_token`: Get new access token using refresh token
   * <br><br>
   * <b>Client Authentication:</b><br>
   * Can be provided via:<br>
   * - HTTP Basic auth: `Authorization: Basic base64(client_id:client_secret)`<br>
   * - Request body: `client_id` and `client_secret` parameters
   * <br><br>
   * <b>PKCE Verification:</b><br>
   * If authorization used PKCE, the `code_verifier` must be provided and will be
   * verified against the stored code challenge.
   */
  async exchange(
    request: models.OAuthTokenRequest,
    options?: RequestOptions,
  ): Promise<models.OAuthTokenResponse> {
    return unwrapAsync(oauthProviderExchange(
      this,
      request,
      options,
    ));
  }

  /**
   * Revoke an access or refresh token
   *
   * @remarks
   * OAuth 2.0 Token Revocation Endpoint (RFC 7009).
   * <br><br>
   * Revokes an access token or refresh token, preventing further use.
   * Revoking a refresh token also invalidates associated access tokens.
   * <br><br>
   * <b>Use Cases:</b><br>
   * - User logs out of third-party app<br>
   * - User revokes app access from account settings<br>
   * - Security incident response
   * <br><br>
   * <b>Note:</b> Returns 200 OK even if token was already revoked or invalid
   * (per RFC 7009, to prevent token enumeration).
   */
  async revokeToken(
    request: models.OAuthRevokeRequest,
    options?: RequestOptions,
  ): Promise<void> {
    return unwrapAsync(oauthProviderRevokeToken(
      this,
      request,
      options,
    ));
  }

  /**
   * Introspect a token
   *
   * @remarks
   * OAuth 2.0 Token Introspection Endpoint (RFC 7662).
   * <br><br>
   * Check if a token is active and retrieve its metadata.
   * <br><br>
   * <b>Use Cases:</b><br>
   * - Resource servers validating tokens<br>
   * - Debugging token issues<br>
   * - Checking token scopes before processing requests
   * <br><br>
   * <b>Response:</b><br>
   * - Active token: Returns `active: true` with token metadata<br>
   * - Invalid/expired/revoked token: Returns only `active: false`
   */
  async introspect(
    request: models.OAuthIntrospectRequest,
    options?: RequestOptions,
  ): Promise<models.OAuthIntrospectResponse> {
    return unwrapAsync(oauthProviderIntrospect(
      this,
      request,
      options,
    ));
  }
}
